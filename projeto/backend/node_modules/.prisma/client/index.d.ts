
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model usuario
 * 
 */
export type usuario = $Result.DefaultSelection<Prisma.$usuarioPayload>
/**
 * Model projeto
 * 
 */
export type projeto = $Result.DefaultSelection<Prisma.$projetoPayload>
/**
 * Model tarefa
 * 
 */
export type tarefa = $Result.DefaultSelection<Prisma.$tarefaPayload>
/**
 * Model usuario_projeto
 * 
 */
export type usuario_projeto = $Result.DefaultSelection<Prisma.$usuario_projetoPayload>
/**
 * Model responsavel_tarefa
 * 
 */
export type responsavel_tarefa = $Result.DefaultSelection<Prisma.$responsavel_tarefaPayload>
/**
 * Model comentario
 * 
 */
export type comentario = $Result.DefaultSelection<Prisma.$comentarioPayload>
/**
 * Model todo
 * 
 */
export type todo = $Result.DefaultSelection<Prisma.$todoPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.usuarioDelegate<ExtArgs>;

  /**
   * `prisma.projeto`: Exposes CRUD operations for the **projeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projetos
    * const projetos = await prisma.projeto.findMany()
    * ```
    */
  get projeto(): Prisma.projetoDelegate<ExtArgs>;

  /**
   * `prisma.tarefa`: Exposes CRUD operations for the **tarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tarefas
    * const tarefas = await prisma.tarefa.findMany()
    * ```
    */
  get tarefa(): Prisma.tarefaDelegate<ExtArgs>;

  /**
   * `prisma.usuario_projeto`: Exposes CRUD operations for the **usuario_projeto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuario_projetos
    * const usuario_projetos = await prisma.usuario_projeto.findMany()
    * ```
    */
  get usuario_projeto(): Prisma.usuario_projetoDelegate<ExtArgs>;

  /**
   * `prisma.responsavel_tarefa`: Exposes CRUD operations for the **responsavel_tarefa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responsavel_tarefas
    * const responsavel_tarefas = await prisma.responsavel_tarefa.findMany()
    * ```
    */
  get responsavel_tarefa(): Prisma.responsavel_tarefaDelegate<ExtArgs>;

  /**
   * `prisma.comentario`: Exposes CRUD operations for the **comentario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comentarios
    * const comentarios = await prisma.comentario.findMany()
    * ```
    */
  get comentario(): Prisma.comentarioDelegate<ExtArgs>;

  /**
   * `prisma.todo`: Exposes CRUD operations for the **todo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Todos
    * const todos = await prisma.todo.findMany()
    * ```
    */
  get todo(): Prisma.todoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    usuario: 'usuario',
    projeto: 'projeto',
    tarefa: 'tarefa',
    usuario_projeto: 'usuario_projeto',
    responsavel_tarefa: 'responsavel_tarefa',
    comentario: 'comentario',
    todo: 'todo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "projeto" | "tarefa" | "usuario_projeto" | "responsavel_tarefa" | "comentario" | "todo"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      usuario: {
        payload: Prisma.$usuarioPayload<ExtArgs>
        fields: Prisma.usuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findFirst: {
            args: Prisma.usuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          findMany: {
            args: Prisma.usuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>[]
          }
          create: {
            args: Prisma.usuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          createMany: {
            args: Prisma.usuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          update: {
            args: Prisma.usuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          deleteMany: {
            args: Prisma.usuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.usuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      projeto: {
        payload: Prisma.$projetoPayload<ExtArgs>
        fields: Prisma.projetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          findFirst: {
            args: Prisma.projetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          findMany: {
            args: Prisma.projetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>[]
          }
          create: {
            args: Prisma.projetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          createMany: {
            args: Prisma.projetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.projetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          update: {
            args: Prisma.projetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          deleteMany: {
            args: Prisma.projetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.projetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projetoPayload>
          }
          aggregate: {
            args: Prisma.ProjetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjeto>
          }
          groupBy: {
            args: Prisma.projetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.projetoCountArgs<ExtArgs>
            result: $Utils.Optional<ProjetoCountAggregateOutputType> | number
          }
        }
      }
      tarefa: {
        payload: Prisma.$tarefaPayload<ExtArgs>
        fields: Prisma.tarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          findFirst: {
            args: Prisma.tarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          findMany: {
            args: Prisma.tarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>[]
          }
          create: {
            args: Prisma.tarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          createMany: {
            args: Prisma.tarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          update: {
            args: Prisma.tarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          deleteMany: {
            args: Prisma.tarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tarefaPayload>
          }
          aggregate: {
            args: Prisma.TarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTarefa>
          }
          groupBy: {
            args: Prisma.tarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tarefaCountArgs<ExtArgs>
            result: $Utils.Optional<TarefaCountAggregateOutputType> | number
          }
        }
      }
      usuario_projeto: {
        payload: Prisma.$usuario_projetoPayload<ExtArgs>
        fields: Prisma.usuario_projetoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usuario_projetoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usuario_projetoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          findFirst: {
            args: Prisma.usuario_projetoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usuario_projetoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          findMany: {
            args: Prisma.usuario_projetoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>[]
          }
          create: {
            args: Prisma.usuario_projetoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          createMany: {
            args: Prisma.usuario_projetoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usuario_projetoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          update: {
            args: Prisma.usuario_projetoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          deleteMany: {
            args: Prisma.usuario_projetoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usuario_projetoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usuario_projetoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usuario_projetoPayload>
          }
          aggregate: {
            args: Prisma.Usuario_projetoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario_projeto>
          }
          groupBy: {
            args: Prisma.usuario_projetoGroupByArgs<ExtArgs>
            result: $Utils.Optional<Usuario_projetoGroupByOutputType>[]
          }
          count: {
            args: Prisma.usuario_projetoCountArgs<ExtArgs>
            result: $Utils.Optional<Usuario_projetoCountAggregateOutputType> | number
          }
        }
      }
      responsavel_tarefa: {
        payload: Prisma.$responsavel_tarefaPayload<ExtArgs>
        fields: Prisma.responsavel_tarefaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.responsavel_tarefaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.responsavel_tarefaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          findFirst: {
            args: Prisma.responsavel_tarefaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.responsavel_tarefaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          findMany: {
            args: Prisma.responsavel_tarefaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>[]
          }
          create: {
            args: Prisma.responsavel_tarefaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          createMany: {
            args: Prisma.responsavel_tarefaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.responsavel_tarefaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          update: {
            args: Prisma.responsavel_tarefaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          deleteMany: {
            args: Prisma.responsavel_tarefaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.responsavel_tarefaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.responsavel_tarefaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$responsavel_tarefaPayload>
          }
          aggregate: {
            args: Prisma.Responsavel_tarefaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResponsavel_tarefa>
          }
          groupBy: {
            args: Prisma.responsavel_tarefaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Responsavel_tarefaGroupByOutputType>[]
          }
          count: {
            args: Prisma.responsavel_tarefaCountArgs<ExtArgs>
            result: $Utils.Optional<Responsavel_tarefaCountAggregateOutputType> | number
          }
        }
      }
      comentario: {
        payload: Prisma.$comentarioPayload<ExtArgs>
        fields: Prisma.comentarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comentarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comentarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          findFirst: {
            args: Prisma.comentarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comentarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          findMany: {
            args: Prisma.comentarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>[]
          }
          create: {
            args: Prisma.comentarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          createMany: {
            args: Prisma.comentarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.comentarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          update: {
            args: Prisma.comentarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          deleteMany: {
            args: Prisma.comentarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comentarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.comentarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comentarioPayload>
          }
          aggregate: {
            args: Prisma.ComentarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComentario>
          }
          groupBy: {
            args: Prisma.comentarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComentarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.comentarioCountArgs<ExtArgs>
            result: $Utils.Optional<ComentarioCountAggregateOutputType> | number
          }
        }
      }
      todo: {
        payload: Prisma.$todoPayload<ExtArgs>
        fields: Prisma.todoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.todoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.todoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          findFirst: {
            args: Prisma.todoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.todoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          findMany: {
            args: Prisma.todoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>[]
          }
          create: {
            args: Prisma.todoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          createMany: {
            args: Prisma.todoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.todoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          update: {
            args: Prisma.todoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          deleteMany: {
            args: Prisma.todoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.todoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.todoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$todoPayload>
          }
          aggregate: {
            args: Prisma.TodoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodo>
          }
          groupBy: {
            args: Prisma.todoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoGroupByOutputType>[]
          }
          count: {
            args: Prisma.todoCountArgs<ExtArgs>
            result: $Utils.Optional<TodoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    projetos: number
    tarefas: number
    comentarios: number
    responsaveis: number
    projetos_gestor: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetos?: boolean | UsuarioCountOutputTypeCountProjetosArgs
    tarefas?: boolean | UsuarioCountOutputTypeCountTarefasArgs
    comentarios?: boolean | UsuarioCountOutputTypeCountComentariosArgs
    responsaveis?: boolean | UsuarioCountOutputTypeCountResponsaveisArgs
    projetos_gestor?: boolean | UsuarioCountOutputTypeCountProjetos_gestorArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProjetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_projetoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTarefasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tarefaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountComentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountResponsaveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsavel_tarefaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProjetos_gestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoWhereInput
  }


  /**
   * Count Type ProjetoCountOutputType
   */

  export type ProjetoCountOutputType = {
    usuarios: number
    tarefa: number
  }

  export type ProjetoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | ProjetoCountOutputTypeCountUsuariosArgs
    tarefa?: boolean | ProjetoCountOutputTypeCountTarefaArgs
  }

  // Custom InputTypes
  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjetoCountOutputType
     */
    select?: ProjetoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountUsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_projetoWhereInput
  }

  /**
   * ProjetoCountOutputType without action
   */
  export type ProjetoCountOutputTypeCountTarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tarefaWhereInput
  }


  /**
   * Count Type TarefaCountOutputType
   */

  export type TarefaCountOutputType = {
    comentario: number
    responsavel_tarefa: number
  }

  export type TarefaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comentario?: boolean | TarefaCountOutputTypeCountComentarioArgs
    responsavel_tarefa?: boolean | TarefaCountOutputTypeCountResponsavel_tarefaArgs
  }

  // Custom InputTypes
  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TarefaCountOutputType
     */
    select?: TarefaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountComentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
  }

  /**
   * TarefaCountOutputType without action
   */
  export type TarefaCountOutputTypeCountResponsavel_tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsavel_tarefaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    idusuario: number | null
    usuario_tipo: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    idusuario: number | null
    usuario_tipo: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    idusuario: number | null
    cpf: string | null
    nome: string | null
    hash_senha: string | null
    email: string | null
    papel: string | null
    usuario_tipo: number | null
  }

  export type UsuarioMaxAggregateOutputType = {
    idusuario: number | null
    cpf: string | null
    nome: string | null
    hash_senha: string | null
    email: string | null
    papel: string | null
    usuario_tipo: number | null
  }

  export type UsuarioCountAggregateOutputType = {
    idusuario: number
    cpf: number
    nome: number
    hash_senha: number
    email: number
    papel: number
    usuario_tipo: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    idusuario?: true
    usuario_tipo?: true
  }

  export type UsuarioSumAggregateInputType = {
    idusuario?: true
    usuario_tipo?: true
  }

  export type UsuarioMinAggregateInputType = {
    idusuario?: true
    cpf?: true
    nome?: true
    hash_senha?: true
    email?: true
    papel?: true
    usuario_tipo?: true
  }

  export type UsuarioMaxAggregateInputType = {
    idusuario?: true
    cpf?: true
    nome?: true
    hash_senha?: true
    email?: true
    papel?: true
    usuario_tipo?: true
  }

  export type UsuarioCountAggregateInputType = {
    idusuario?: true
    cpf?: true
    nome?: true
    hash_senha?: true
    email?: true
    papel?: true
    usuario_tipo?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario to aggregate.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type usuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuarioWhereInput
    orderBy?: usuarioOrderByWithAggregationInput | usuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: usuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    idusuario: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo: number
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends usuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type usuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idusuario?: boolean
    cpf?: boolean
    nome?: boolean
    hash_senha?: boolean
    email?: boolean
    papel?: boolean
    usuario_tipo?: boolean
    projetos?: boolean | usuario$projetosArgs<ExtArgs>
    tarefas?: boolean | usuario$tarefasArgs<ExtArgs>
    comentarios?: boolean | usuario$comentariosArgs<ExtArgs>
    responsaveis?: boolean | usuario$responsaveisArgs<ExtArgs>
    projetos_gestor?: boolean | usuario$projetos_gestorArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>


  export type usuarioSelectScalar = {
    idusuario?: boolean
    cpf?: boolean
    nome?: boolean
    hash_senha?: boolean
    email?: boolean
    papel?: boolean
    usuario_tipo?: boolean
  }

  export type usuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projetos?: boolean | usuario$projetosArgs<ExtArgs>
    tarefas?: boolean | usuario$tarefasArgs<ExtArgs>
    comentarios?: boolean | usuario$comentariosArgs<ExtArgs>
    responsaveis?: boolean | usuario$responsaveisArgs<ExtArgs>
    projetos_gestor?: boolean | usuario$projetos_gestorArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario"
    objects: {
      projetos: Prisma.$usuario_projetoPayload<ExtArgs>[]
      tarefas: Prisma.$tarefaPayload<ExtArgs>[]
      comentarios: Prisma.$comentarioPayload<ExtArgs>[]
      responsaveis: Prisma.$responsavel_tarefaPayload<ExtArgs>[]
      projetos_gestor: Prisma.$projetoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idusuario: number
      cpf: string
      nome: string
      hash_senha: string
      email: string
      papel: string
      usuario_tipo: number
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type usuarioGetPayload<S extends boolean | null | undefined | usuarioDefaultArgs> = $Result.GetResult<Prisma.$usuarioPayload, S>

  type usuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface usuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario'], meta: { name: 'usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {usuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuarioFindUniqueArgs>(args: SelectSubset<T, usuarioFindUniqueArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, usuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuarioFindFirstArgs>(args?: SelectSubset<T, usuarioFindFirstArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, usuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `idusuario`
     * const usuarioWithIdusuarioOnly = await prisma.usuario.findMany({ select: { idusuario: true } })
     * 
     */
    findMany<T extends usuarioFindManyArgs>(args?: SelectSubset<T, usuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {usuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends usuarioCreateArgs>(args: SelectSubset<T, usuarioCreateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {usuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuarioCreateManyArgs>(args?: SelectSubset<T, usuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario.
     * @param {usuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends usuarioDeleteArgs>(args: SelectSubset<T, usuarioDeleteArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {usuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuarioUpdateArgs>(args: SelectSubset<T, usuarioUpdateArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {usuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuarioDeleteManyArgs>(args?: SelectSubset<T, usuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuarioUpdateManyArgs>(args: SelectSubset<T, usuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {usuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends usuarioUpsertArgs>(args: SelectSubset<T, usuarioUpsertArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends usuarioCountArgs>(
      args?: Subset<T, usuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuarioGroupByArgs['orderBy'] }
        : { orderBy?: usuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario model
   */
  readonly fields: usuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projetos<T extends usuario$projetosArgs<ExtArgs> = {}>(args?: Subset<T, usuario$projetosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findMany"> | Null>
    tarefas<T extends usuario$tarefasArgs<ExtArgs> = {}>(args?: Subset<T, usuario$tarefasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findMany"> | Null>
    comentarios<T extends usuario$comentariosArgs<ExtArgs> = {}>(args?: Subset<T, usuario$comentariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany"> | Null>
    responsaveis<T extends usuario$responsaveisArgs<ExtArgs> = {}>(args?: Subset<T, usuario$responsaveisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findMany"> | Null>
    projetos_gestor<T extends usuario$projetos_gestorArgs<ExtArgs> = {}>(args?: Subset<T, usuario$projetos_gestorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario model
   */ 
  interface usuarioFieldRefs {
    readonly idusuario: FieldRef<"usuario", 'Int'>
    readonly cpf: FieldRef<"usuario", 'String'>
    readonly nome: FieldRef<"usuario", 'String'>
    readonly hash_senha: FieldRef<"usuario", 'String'>
    readonly email: FieldRef<"usuario", 'String'>
    readonly papel: FieldRef<"usuario", 'String'>
    readonly usuario_tipo: FieldRef<"usuario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usuario findUnique
   */
  export type usuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findUniqueOrThrow
   */
  export type usuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario findFirst
   */
  export type usuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findFirstOrThrow
   */
  export type usuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuario to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario findMany
   */
  export type usuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter, which usuarios to fetch.
     */
    where?: usuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuarios to fetch.
     */
    orderBy?: usuarioOrderByWithRelationInput | usuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuarios.
     */
    cursor?: usuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * usuario create
   */
  export type usuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario.
     */
    data: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
  }

  /**
   * usuario createMany
   */
  export type usuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuarios.
     */
    data: usuarioCreateManyInput | usuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario update
   */
  export type usuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario.
     */
    data: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
    /**
     * Choose, which usuario to update.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario updateMany
   */
  export type usuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuarios.
     */
    data: XOR<usuarioUpdateManyMutationInput, usuarioUncheckedUpdateManyInput>
    /**
     * Filter which usuarios to update
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario upsert
   */
  export type usuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario to update in case it exists.
     */
    where: usuarioWhereUniqueInput
    /**
     * In case the usuario found by the `where` argument doesn't exist, create a new usuario with this data.
     */
    create: XOR<usuarioCreateInput, usuarioUncheckedCreateInput>
    /**
     * In case the usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuarioUpdateInput, usuarioUncheckedUpdateInput>
  }

  /**
   * usuario delete
   */
  export type usuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    /**
     * Filter which usuario to delete.
     */
    where: usuarioWhereUniqueInput
  }

  /**
   * usuario deleteMany
   */
  export type usuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuarios to delete
     */
    where?: usuarioWhereInput
  }

  /**
   * usuario.projetos
   */
  export type usuario$projetosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    where?: usuario_projetoWhereInput
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    cursor?: usuario_projetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuario_projetoScalarFieldEnum | Usuario_projetoScalarFieldEnum[]
  }

  /**
   * usuario.tarefas
   */
  export type usuario$tarefasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    where?: tarefaWhereInput
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    cursor?: tarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * usuario.comentarios
   */
  export type usuario$comentariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    cursor?: comentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * usuario.responsaveis
   */
  export type usuario$responsaveisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    where?: responsavel_tarefaWhereInput
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    cursor?: responsavel_tarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Responsavel_tarefaScalarFieldEnum | Responsavel_tarefaScalarFieldEnum[]
  }

  /**
   * usuario.projetos_gestor
   */
  export type usuario$projetos_gestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    where?: projetoWhereInput
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    cursor?: projetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * usuario without action
   */
  export type usuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
  }


  /**
   * Model projeto
   */

  export type AggregateProjeto = {
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  export type ProjetoAvgAggregateOutputType = {
    idprojeto: number | null
    valor: Decimal | null
    id_gestor: number | null
  }

  export type ProjetoSumAggregateOutputType = {
    idprojeto: number | null
    valor: Decimal | null
    id_gestor: number | null
  }

  export type ProjetoMinAggregateOutputType = {
    idprojeto: number | null
    nome: string | null
    valor: Decimal | null
    data_inicio: Date | null
    prazo: Date | null
    status: string | null
    descricao: string | null
    foto: Buffer | null
    id_gestor: number | null
  }

  export type ProjetoMaxAggregateOutputType = {
    idprojeto: number | null
    nome: string | null
    valor: Decimal | null
    data_inicio: Date | null
    prazo: Date | null
    status: string | null
    descricao: string | null
    foto: Buffer | null
    id_gestor: number | null
  }

  export type ProjetoCountAggregateOutputType = {
    idprojeto: number
    nome: number
    valor: number
    data_inicio: number
    prazo: number
    status: number
    descricao: number
    foto: number
    id_gestor: number
    _all: number
  }


  export type ProjetoAvgAggregateInputType = {
    idprojeto?: true
    valor?: true
    id_gestor?: true
  }

  export type ProjetoSumAggregateInputType = {
    idprojeto?: true
    valor?: true
    id_gestor?: true
  }

  export type ProjetoMinAggregateInputType = {
    idprojeto?: true
    nome?: true
    valor?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    foto?: true
    id_gestor?: true
  }

  export type ProjetoMaxAggregateInputType = {
    idprojeto?: true
    nome?: true
    valor?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    foto?: true
    id_gestor?: true
  }

  export type ProjetoCountAggregateInputType = {
    idprojeto?: true
    nome?: true
    valor?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    foto?: true
    id_gestor?: true
    _all?: true
  }

  export type ProjetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projeto to aggregate.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projetos
    **/
    _count?: true | ProjetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjetoMaxAggregateInputType
  }

  export type GetProjetoAggregateType<T extends ProjetoAggregateArgs> = {
        [P in keyof T & keyof AggregateProjeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjeto[P]>
      : GetScalarType<T[P], AggregateProjeto[P]>
  }




  export type projetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projetoWhereInput
    orderBy?: projetoOrderByWithAggregationInput | projetoOrderByWithAggregationInput[]
    by: ProjetoScalarFieldEnum[] | ProjetoScalarFieldEnum
    having?: projetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjetoCountAggregateInputType | true
    _avg?: ProjetoAvgAggregateInputType
    _sum?: ProjetoSumAggregateInputType
    _min?: ProjetoMinAggregateInputType
    _max?: ProjetoMaxAggregateInputType
  }

  export type ProjetoGroupByOutputType = {
    idprojeto: number
    nome: string
    valor: Decimal
    data_inicio: Date
    prazo: Date
    status: string
    descricao: string
    foto: Buffer
    id_gestor: number
    _count: ProjetoCountAggregateOutputType | null
    _avg: ProjetoAvgAggregateOutputType | null
    _sum: ProjetoSumAggregateOutputType | null
    _min: ProjetoMinAggregateOutputType | null
    _max: ProjetoMaxAggregateOutputType | null
  }

  type GetProjetoGroupByPayload<T extends projetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
            : GetScalarType<T[P], ProjetoGroupByOutputType[P]>
        }
      >
    >


  export type projetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idprojeto?: boolean
    nome?: boolean
    valor?: boolean
    data_inicio?: boolean
    prazo?: boolean
    status?: boolean
    descricao?: boolean
    foto?: boolean
    id_gestor?: boolean
    usuarios?: boolean | projeto$usuariosArgs<ExtArgs>
    gestor?: boolean | projeto$gestorArgs<ExtArgs>
    tarefa?: boolean | projeto$tarefaArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projeto"]>


  export type projetoSelectScalar = {
    idprojeto?: boolean
    nome?: boolean
    valor?: boolean
    data_inicio?: boolean
    prazo?: boolean
    status?: boolean
    descricao?: boolean
    foto?: boolean
    id_gestor?: boolean
  }

  export type projetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | projeto$usuariosArgs<ExtArgs>
    gestor?: boolean | projeto$gestorArgs<ExtArgs>
    tarefa?: boolean | projeto$tarefaArgs<ExtArgs>
    _count?: boolean | ProjetoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $projetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projeto"
    objects: {
      usuarios: Prisma.$usuario_projetoPayload<ExtArgs>[]
      gestor: Prisma.$usuarioPayload<ExtArgs> | null
      tarefa: Prisma.$tarefaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idprojeto: number
      nome: string
      valor: Prisma.Decimal
      data_inicio: Date
      prazo: Date
      status: string
      descricao: string
      foto: Buffer
      id_gestor: number
    }, ExtArgs["result"]["projeto"]>
    composites: {}
  }

  type projetoGetPayload<S extends boolean | null | undefined | projetoDefaultArgs> = $Result.GetResult<Prisma.$projetoPayload, S>

  type projetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<projetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProjetoCountAggregateInputType | true
    }

  export interface projetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projeto'], meta: { name: 'projeto' } }
    /**
     * Find zero or one Projeto that matches the filter.
     * @param {projetoFindUniqueArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projetoFindUniqueArgs>(args: SelectSubset<T, projetoFindUniqueArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Projeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {projetoFindUniqueOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projetoFindUniqueOrThrowArgs>(args: SelectSubset<T, projetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Projeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projetoFindFirstArgs>(args?: SelectSubset<T, projetoFindFirstArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Projeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindFirstOrThrowArgs} args - Arguments to find a Projeto
     * @example
     * // Get one Projeto
     * const projeto = await prisma.projeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projetoFindFirstOrThrowArgs>(args?: SelectSubset<T, projetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Projetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projetos
     * const projetos = await prisma.projeto.findMany()
     * 
     * // Get first 10 Projetos
     * const projetos = await prisma.projeto.findMany({ take: 10 })
     * 
     * // Only select the `idprojeto`
     * const projetoWithIdprojetoOnly = await prisma.projeto.findMany({ select: { idprojeto: true } })
     * 
     */
    findMany<T extends projetoFindManyArgs>(args?: SelectSubset<T, projetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Projeto.
     * @param {projetoCreateArgs} args - Arguments to create a Projeto.
     * @example
     * // Create one Projeto
     * const Projeto = await prisma.projeto.create({
     *   data: {
     *     // ... data to create a Projeto
     *   }
     * })
     * 
     */
    create<T extends projetoCreateArgs>(args: SelectSubset<T, projetoCreateArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Projetos.
     * @param {projetoCreateManyArgs} args - Arguments to create many Projetos.
     * @example
     * // Create many Projetos
     * const projeto = await prisma.projeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projetoCreateManyArgs>(args?: SelectSubset<T, projetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Projeto.
     * @param {projetoDeleteArgs} args - Arguments to delete one Projeto.
     * @example
     * // Delete one Projeto
     * const Projeto = await prisma.projeto.delete({
     *   where: {
     *     // ... filter to delete one Projeto
     *   }
     * })
     * 
     */
    delete<T extends projetoDeleteArgs>(args: SelectSubset<T, projetoDeleteArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Projeto.
     * @param {projetoUpdateArgs} args - Arguments to update one Projeto.
     * @example
     * // Update one Projeto
     * const projeto = await prisma.projeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projetoUpdateArgs>(args: SelectSubset<T, projetoUpdateArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Projetos.
     * @param {projetoDeleteManyArgs} args - Arguments to filter Projetos to delete.
     * @example
     * // Delete a few Projetos
     * const { count } = await prisma.projeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projetoDeleteManyArgs>(args?: SelectSubset<T, projetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projetos
     * const projeto = await prisma.projeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projetoUpdateManyArgs>(args: SelectSubset<T, projetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Projeto.
     * @param {projetoUpsertArgs} args - Arguments to update or create a Projeto.
     * @example
     * // Update or create a Projeto
     * const projeto = await prisma.projeto.upsert({
     *   create: {
     *     // ... data to create a Projeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projeto we want to update
     *   }
     * })
     */
    upsert<T extends projetoUpsertArgs>(args: SelectSubset<T, projetoUpsertArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoCountArgs} args - Arguments to filter Projetos to count.
     * @example
     * // Count the number of Projetos
     * const count = await prisma.projeto.count({
     *   where: {
     *     // ... the filter for the Projetos we want to count
     *   }
     * })
    **/
    count<T extends projetoCountArgs>(
      args?: Subset<T, projetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjetoAggregateArgs>(args: Subset<T, ProjetoAggregateArgs>): Prisma.PrismaPromise<GetProjetoAggregateType<T>>

    /**
     * Group by Projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projetoGroupByArgs['orderBy'] }
        : { orderBy?: projetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projeto model
   */
  readonly fields: projetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuarios<T extends projeto$usuariosArgs<ExtArgs> = {}>(args?: Subset<T, projeto$usuariosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findMany"> | Null>
    gestor<T extends projeto$gestorArgs<ExtArgs> = {}>(args?: Subset<T, projeto$gestorArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tarefa<T extends projeto$tarefaArgs<ExtArgs> = {}>(args?: Subset<T, projeto$tarefaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projeto model
   */ 
  interface projetoFieldRefs {
    readonly idprojeto: FieldRef<"projeto", 'Int'>
    readonly nome: FieldRef<"projeto", 'String'>
    readonly valor: FieldRef<"projeto", 'Decimal'>
    readonly data_inicio: FieldRef<"projeto", 'DateTime'>
    readonly prazo: FieldRef<"projeto", 'DateTime'>
    readonly status: FieldRef<"projeto", 'String'>
    readonly descricao: FieldRef<"projeto", 'String'>
    readonly foto: FieldRef<"projeto", 'Bytes'>
    readonly id_gestor: FieldRef<"projeto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projeto findUnique
   */
  export type projetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto findUniqueOrThrow
   */
  export type projetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto findFirst
   */
  export type projetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto findFirstOrThrow
   */
  export type projetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projeto to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projetos.
     */
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto findMany
   */
  export type projetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter, which projetos to fetch.
     */
    where?: projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projetos to fetch.
     */
    orderBy?: projetoOrderByWithRelationInput | projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projetos.
     */
    cursor?: projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projetos.
     */
    skip?: number
    distinct?: ProjetoScalarFieldEnum | ProjetoScalarFieldEnum[]
  }

  /**
   * projeto create
   */
  export type projetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The data needed to create a projeto.
     */
    data: XOR<projetoCreateInput, projetoUncheckedCreateInput>
  }

  /**
   * projeto createMany
   */
  export type projetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projetos.
     */
    data: projetoCreateManyInput | projetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projeto update
   */
  export type projetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The data needed to update a projeto.
     */
    data: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>
    /**
     * Choose, which projeto to update.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto updateMany
   */
  export type projetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projetos.
     */
    data: XOR<projetoUpdateManyMutationInput, projetoUncheckedUpdateManyInput>
    /**
     * Filter which projetos to update
     */
    where?: projetoWhereInput
  }

  /**
   * projeto upsert
   */
  export type projetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * The filter to search for the projeto to update in case it exists.
     */
    where: projetoWhereUniqueInput
    /**
     * In case the projeto found by the `where` argument doesn't exist, create a new projeto with this data.
     */
    create: XOR<projetoCreateInput, projetoUncheckedCreateInput>
    /**
     * In case the projeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projetoUpdateInput, projetoUncheckedUpdateInput>
  }

  /**
   * projeto delete
   */
  export type projetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    /**
     * Filter which projeto to delete.
     */
    where: projetoWhereUniqueInput
  }

  /**
   * projeto deleteMany
   */
  export type projetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projetos to delete
     */
    where?: projetoWhereInput
  }

  /**
   * projeto.usuarios
   */
  export type projeto$usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    where?: usuario_projetoWhereInput
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    cursor?: usuario_projetoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Usuario_projetoScalarFieldEnum | Usuario_projetoScalarFieldEnum[]
  }

  /**
   * projeto.gestor
   */
  export type projeto$gestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * projeto.tarefa
   */
  export type projeto$tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    where?: tarefaWhereInput
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    cursor?: tarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * projeto without action
   */
  export type projetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
  }


  /**
   * Model tarefa
   */

  export type AggregateTarefa = {
    _count: TarefaCountAggregateOutputType | null
    _avg: TarefaAvgAggregateOutputType | null
    _sum: TarefaSumAggregateOutputType | null
    _min: TarefaMinAggregateOutputType | null
    _max: TarefaMaxAggregateOutputType | null
  }

  export type TarefaAvgAggregateOutputType = {
    idtarefa: number | null
    id_projeto: number | null
    id_gestor: number | null
  }

  export type TarefaSumAggregateOutputType = {
    idtarefa: number | null
    id_projeto: number | null
    id_gestor: number | null
  }

  export type TarefaMinAggregateOutputType = {
    idtarefa: number | null
    nome: string | null
    data_inicio: Date | null
    prazo: Date | null
    status: string | null
    descricao: string | null
    id_projeto: number | null
    id_gestor: number | null
  }

  export type TarefaMaxAggregateOutputType = {
    idtarefa: number | null
    nome: string | null
    data_inicio: Date | null
    prazo: Date | null
    status: string | null
    descricao: string | null
    id_projeto: number | null
    id_gestor: number | null
  }

  export type TarefaCountAggregateOutputType = {
    idtarefa: number
    nome: number
    data_inicio: number
    prazo: number
    status: number
    descricao: number
    id_projeto: number
    id_gestor: number
    _all: number
  }


  export type TarefaAvgAggregateInputType = {
    idtarefa?: true
    id_projeto?: true
    id_gestor?: true
  }

  export type TarefaSumAggregateInputType = {
    idtarefa?: true
    id_projeto?: true
    id_gestor?: true
  }

  export type TarefaMinAggregateInputType = {
    idtarefa?: true
    nome?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    id_projeto?: true
    id_gestor?: true
  }

  export type TarefaMaxAggregateInputType = {
    idtarefa?: true
    nome?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    id_projeto?: true
    id_gestor?: true
  }

  export type TarefaCountAggregateInputType = {
    idtarefa?: true
    nome?: true
    data_inicio?: true
    prazo?: true
    status?: true
    descricao?: true
    id_projeto?: true
    id_gestor?: true
    _all?: true
  }

  export type TarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tarefa to aggregate.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tarefas
    **/
    _count?: true | TarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TarefaMaxAggregateInputType
  }

  export type GetTarefaAggregateType<T extends TarefaAggregateArgs> = {
        [P in keyof T & keyof AggregateTarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTarefa[P]>
      : GetScalarType<T[P], AggregateTarefa[P]>
  }




  export type tarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tarefaWhereInput
    orderBy?: tarefaOrderByWithAggregationInput | tarefaOrderByWithAggregationInput[]
    by: TarefaScalarFieldEnum[] | TarefaScalarFieldEnum
    having?: tarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TarefaCountAggregateInputType | true
    _avg?: TarefaAvgAggregateInputType
    _sum?: TarefaSumAggregateInputType
    _min?: TarefaMinAggregateInputType
    _max?: TarefaMaxAggregateInputType
  }

  export type TarefaGroupByOutputType = {
    idtarefa: number
    nome: string | null
    data_inicio: Date | null
    prazo: Date | null
    status: string | null
    descricao: string | null
    id_projeto: number | null
    id_gestor: number | null
    _count: TarefaCountAggregateOutputType | null
    _avg: TarefaAvgAggregateOutputType | null
    _sum: TarefaSumAggregateOutputType | null
    _min: TarefaMinAggregateOutputType | null
    _max: TarefaMaxAggregateOutputType | null
  }

  type GetTarefaGroupByPayload<T extends tarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TarefaGroupByOutputType[P]>
            : GetScalarType<T[P], TarefaGroupByOutputType[P]>
        }
      >
    >


  export type tarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idtarefa?: boolean
    nome?: boolean
    data_inicio?: boolean
    prazo?: boolean
    status?: boolean
    descricao?: boolean
    id_projeto?: boolean
    id_gestor?: boolean
    projeto?: boolean | tarefa$projetoArgs<ExtArgs>
    gestor?: boolean | tarefa$gestorArgs<ExtArgs>
    comentario?: boolean | tarefa$comentarioArgs<ExtArgs>
    responsavel_tarefa?: boolean | tarefa$responsavel_tarefaArgs<ExtArgs>
    _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tarefa"]>


  export type tarefaSelectScalar = {
    idtarefa?: boolean
    nome?: boolean
    data_inicio?: boolean
    prazo?: boolean
    status?: boolean
    descricao?: boolean
    id_projeto?: boolean
    id_gestor?: boolean
  }

  export type tarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projeto?: boolean | tarefa$projetoArgs<ExtArgs>
    gestor?: boolean | tarefa$gestorArgs<ExtArgs>
    comentario?: boolean | tarefa$comentarioArgs<ExtArgs>
    responsavel_tarefa?: boolean | tarefa$responsavel_tarefaArgs<ExtArgs>
    _count?: boolean | TarefaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $tarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tarefa"
    objects: {
      projeto: Prisma.$projetoPayload<ExtArgs> | null
      gestor: Prisma.$usuarioPayload<ExtArgs> | null
      comentario: Prisma.$comentarioPayload<ExtArgs>[]
      responsavel_tarefa: Prisma.$responsavel_tarefaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idtarefa: number
      nome: string | null
      data_inicio: Date | null
      prazo: Date | null
      status: string | null
      descricao: string | null
      id_projeto: number | null
      id_gestor: number | null
    }, ExtArgs["result"]["tarefa"]>
    composites: {}
  }

  type tarefaGetPayload<S extends boolean | null | undefined | tarefaDefaultArgs> = $Result.GetResult<Prisma.$tarefaPayload, S>

  type tarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<tarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TarefaCountAggregateInputType | true
    }

  export interface tarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tarefa'], meta: { name: 'tarefa' } }
    /**
     * Find zero or one Tarefa that matches the filter.
     * @param {tarefaFindUniqueArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tarefaFindUniqueArgs>(args: SelectSubset<T, tarefaFindUniqueArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {tarefaFindUniqueOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, tarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tarefaFindFirstArgs>(args?: SelectSubset<T, tarefaFindFirstArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindFirstOrThrowArgs} args - Arguments to find a Tarefa
     * @example
     * // Get one Tarefa
     * const tarefa = await prisma.tarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, tarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tarefas
     * const tarefas = await prisma.tarefa.findMany()
     * 
     * // Get first 10 Tarefas
     * const tarefas = await prisma.tarefa.findMany({ take: 10 })
     * 
     * // Only select the `idtarefa`
     * const tarefaWithIdtarefaOnly = await prisma.tarefa.findMany({ select: { idtarefa: true } })
     * 
     */
    findMany<T extends tarefaFindManyArgs>(args?: SelectSubset<T, tarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tarefa.
     * @param {tarefaCreateArgs} args - Arguments to create a Tarefa.
     * @example
     * // Create one Tarefa
     * const Tarefa = await prisma.tarefa.create({
     *   data: {
     *     // ... data to create a Tarefa
     *   }
     * })
     * 
     */
    create<T extends tarefaCreateArgs>(args: SelectSubset<T, tarefaCreateArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tarefas.
     * @param {tarefaCreateManyArgs} args - Arguments to create many Tarefas.
     * @example
     * // Create many Tarefas
     * const tarefa = await prisma.tarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tarefaCreateManyArgs>(args?: SelectSubset<T, tarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tarefa.
     * @param {tarefaDeleteArgs} args - Arguments to delete one Tarefa.
     * @example
     * // Delete one Tarefa
     * const Tarefa = await prisma.tarefa.delete({
     *   where: {
     *     // ... filter to delete one Tarefa
     *   }
     * })
     * 
     */
    delete<T extends tarefaDeleteArgs>(args: SelectSubset<T, tarefaDeleteArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tarefa.
     * @param {tarefaUpdateArgs} args - Arguments to update one Tarefa.
     * @example
     * // Update one Tarefa
     * const tarefa = await prisma.tarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tarefaUpdateArgs>(args: SelectSubset<T, tarefaUpdateArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tarefas.
     * @param {tarefaDeleteManyArgs} args - Arguments to filter Tarefas to delete.
     * @example
     * // Delete a few Tarefas
     * const { count } = await prisma.tarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tarefaDeleteManyArgs>(args?: SelectSubset<T, tarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tarefas
     * const tarefa = await prisma.tarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tarefaUpdateManyArgs>(args: SelectSubset<T, tarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tarefa.
     * @param {tarefaUpsertArgs} args - Arguments to update or create a Tarefa.
     * @example
     * // Update or create a Tarefa
     * const tarefa = await prisma.tarefa.upsert({
     *   create: {
     *     // ... data to create a Tarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tarefa we want to update
     *   }
     * })
     */
    upsert<T extends tarefaUpsertArgs>(args: SelectSubset<T, tarefaUpsertArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaCountArgs} args - Arguments to filter Tarefas to count.
     * @example
     * // Count the number of Tarefas
     * const count = await prisma.tarefa.count({
     *   where: {
     *     // ... the filter for the Tarefas we want to count
     *   }
     * })
    **/
    count<T extends tarefaCountArgs>(
      args?: Subset<T, tarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TarefaAggregateArgs>(args: Subset<T, TarefaAggregateArgs>): Prisma.PrismaPromise<GetTarefaAggregateType<T>>

    /**
     * Group by Tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tarefaGroupByArgs['orderBy'] }
        : { orderBy?: tarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tarefa model
   */
  readonly fields: tarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projeto<T extends tarefa$projetoArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$projetoArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    gestor<T extends tarefa$gestorArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$gestorArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comentario<T extends tarefa$comentarioArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$comentarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany"> | Null>
    responsavel_tarefa<T extends tarefa$responsavel_tarefaArgs<ExtArgs> = {}>(args?: Subset<T, tarefa$responsavel_tarefaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tarefa model
   */ 
  interface tarefaFieldRefs {
    readonly idtarefa: FieldRef<"tarefa", 'Int'>
    readonly nome: FieldRef<"tarefa", 'String'>
    readonly data_inicio: FieldRef<"tarefa", 'DateTime'>
    readonly prazo: FieldRef<"tarefa", 'DateTime'>
    readonly status: FieldRef<"tarefa", 'String'>
    readonly descricao: FieldRef<"tarefa", 'String'>
    readonly id_projeto: FieldRef<"tarefa", 'Int'>
    readonly id_gestor: FieldRef<"tarefa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tarefa findUnique
   */
  export type tarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa findUniqueOrThrow
   */
  export type tarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa findFirst
   */
  export type tarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa findFirstOrThrow
   */
  export type tarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefa to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tarefas.
     */
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa findMany
   */
  export type tarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter, which tarefas to fetch.
     */
    where?: tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tarefas to fetch.
     */
    orderBy?: tarefaOrderByWithRelationInput | tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tarefas.
     */
    cursor?: tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tarefas.
     */
    skip?: number
    distinct?: TarefaScalarFieldEnum | TarefaScalarFieldEnum[]
  }

  /**
   * tarefa create
   */
  export type tarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a tarefa.
     */
    data?: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>
  }

  /**
   * tarefa createMany
   */
  export type tarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tarefas.
     */
    data: tarefaCreateManyInput | tarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tarefa update
   */
  export type tarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a tarefa.
     */
    data: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>
    /**
     * Choose, which tarefa to update.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa updateMany
   */
  export type tarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tarefas.
     */
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyInput>
    /**
     * Filter which tarefas to update
     */
    where?: tarefaWhereInput
  }

  /**
   * tarefa upsert
   */
  export type tarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the tarefa to update in case it exists.
     */
    where: tarefaWhereUniqueInput
    /**
     * In case the tarefa found by the `where` argument doesn't exist, create a new tarefa with this data.
     */
    create: XOR<tarefaCreateInput, tarefaUncheckedCreateInput>
    /**
     * In case the tarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tarefaUpdateInput, tarefaUncheckedUpdateInput>
  }

  /**
   * tarefa delete
   */
  export type tarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    /**
     * Filter which tarefa to delete.
     */
    where: tarefaWhereUniqueInput
  }

  /**
   * tarefa deleteMany
   */
  export type tarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tarefas to delete
     */
    where?: tarefaWhereInput
  }

  /**
   * tarefa.projeto
   */
  export type tarefa$projetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projeto
     */
    select?: projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projetoInclude<ExtArgs> | null
    where?: projetoWhereInput
  }

  /**
   * tarefa.gestor
   */
  export type tarefa$gestorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * tarefa.comentario
   */
  export type tarefa$comentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    cursor?: comentarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * tarefa.responsavel_tarefa
   */
  export type tarefa$responsavel_tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    where?: responsavel_tarefaWhereInput
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    cursor?: responsavel_tarefaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Responsavel_tarefaScalarFieldEnum | Responsavel_tarefaScalarFieldEnum[]
  }

  /**
   * tarefa without action
   */
  export type tarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
  }


  /**
   * Model usuario_projeto
   */

  export type AggregateUsuario_projeto = {
    _count: Usuario_projetoCountAggregateOutputType | null
    _avg: Usuario_projetoAvgAggregateOutputType | null
    _sum: Usuario_projetoSumAggregateOutputType | null
    _min: Usuario_projetoMinAggregateOutputType | null
    _max: Usuario_projetoMaxAggregateOutputType | null
  }

  export type Usuario_projetoAvgAggregateOutputType = {
    idusuario: number | null
    idprojeto: number | null
  }

  export type Usuario_projetoSumAggregateOutputType = {
    idusuario: number | null
    idprojeto: number | null
  }

  export type Usuario_projetoMinAggregateOutputType = {
    idusuario: number | null
    idprojeto: number | null
  }

  export type Usuario_projetoMaxAggregateOutputType = {
    idusuario: number | null
    idprojeto: number | null
  }

  export type Usuario_projetoCountAggregateOutputType = {
    idusuario: number
    idprojeto: number
    _all: number
  }


  export type Usuario_projetoAvgAggregateInputType = {
    idusuario?: true
    idprojeto?: true
  }

  export type Usuario_projetoSumAggregateInputType = {
    idusuario?: true
    idprojeto?: true
  }

  export type Usuario_projetoMinAggregateInputType = {
    idusuario?: true
    idprojeto?: true
  }

  export type Usuario_projetoMaxAggregateInputType = {
    idusuario?: true
    idprojeto?: true
  }

  export type Usuario_projetoCountAggregateInputType = {
    idusuario?: true
    idprojeto?: true
    _all?: true
  }

  export type Usuario_projetoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_projeto to aggregate.
     */
    where?: usuario_projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_projetos to fetch.
     */
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usuario_projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned usuario_projetos
    **/
    _count?: true | Usuario_projetoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Usuario_projetoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Usuario_projetoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Usuario_projetoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Usuario_projetoMaxAggregateInputType
  }

  export type GetUsuario_projetoAggregateType<T extends Usuario_projetoAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario_projeto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario_projeto[P]>
      : GetScalarType<T[P], AggregateUsuario_projeto[P]>
  }




  export type usuario_projetoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usuario_projetoWhereInput
    orderBy?: usuario_projetoOrderByWithAggregationInput | usuario_projetoOrderByWithAggregationInput[]
    by: Usuario_projetoScalarFieldEnum[] | Usuario_projetoScalarFieldEnum
    having?: usuario_projetoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Usuario_projetoCountAggregateInputType | true
    _avg?: Usuario_projetoAvgAggregateInputType
    _sum?: Usuario_projetoSumAggregateInputType
    _min?: Usuario_projetoMinAggregateInputType
    _max?: Usuario_projetoMaxAggregateInputType
  }

  export type Usuario_projetoGroupByOutputType = {
    idusuario: number
    idprojeto: number
    _count: Usuario_projetoCountAggregateOutputType | null
    _avg: Usuario_projetoAvgAggregateOutputType | null
    _sum: Usuario_projetoSumAggregateOutputType | null
    _min: Usuario_projetoMinAggregateOutputType | null
    _max: Usuario_projetoMaxAggregateOutputType | null
  }

  type GetUsuario_projetoGroupByPayload<T extends usuario_projetoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Usuario_projetoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Usuario_projetoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Usuario_projetoGroupByOutputType[P]>
            : GetScalarType<T[P], Usuario_projetoGroupByOutputType[P]>
        }
      >
    >


  export type usuario_projetoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idusuario?: boolean
    idprojeto?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario_projeto"]>


  export type usuario_projetoSelectScalar = {
    idusuario?: boolean
    idprojeto?: boolean
  }

  export type usuario_projetoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    projeto?: boolean | projetoDefaultArgs<ExtArgs>
  }

  export type $usuario_projetoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "usuario_projeto"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
      projeto: Prisma.$projetoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idusuario: number
      idprojeto: number
    }, ExtArgs["result"]["usuario_projeto"]>
    composites: {}
  }

  type usuario_projetoGetPayload<S extends boolean | null | undefined | usuario_projetoDefaultArgs> = $Result.GetResult<Prisma.$usuario_projetoPayload, S>

  type usuario_projetoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usuario_projetoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Usuario_projetoCountAggregateInputType | true
    }

  export interface usuario_projetoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['usuario_projeto'], meta: { name: 'usuario_projeto' } }
    /**
     * Find zero or one Usuario_projeto that matches the filter.
     * @param {usuario_projetoFindUniqueArgs} args - Arguments to find a Usuario_projeto
     * @example
     * // Get one Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usuario_projetoFindUniqueArgs>(args: SelectSubset<T, usuario_projetoFindUniqueArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario_projeto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {usuario_projetoFindUniqueOrThrowArgs} args - Arguments to find a Usuario_projeto
     * @example
     * // Get one Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usuario_projetoFindUniqueOrThrowArgs>(args: SelectSubset<T, usuario_projetoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario_projeto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoFindFirstArgs} args - Arguments to find a Usuario_projeto
     * @example
     * // Get one Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usuario_projetoFindFirstArgs>(args?: SelectSubset<T, usuario_projetoFindFirstArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario_projeto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoFindFirstOrThrowArgs} args - Arguments to find a Usuario_projeto
     * @example
     * // Get one Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usuario_projetoFindFirstOrThrowArgs>(args?: SelectSubset<T, usuario_projetoFindFirstOrThrowArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuario_projetos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuario_projetos
     * const usuario_projetos = await prisma.usuario_projeto.findMany()
     * 
     * // Get first 10 Usuario_projetos
     * const usuario_projetos = await prisma.usuario_projeto.findMany({ take: 10 })
     * 
     * // Only select the `idusuario`
     * const usuario_projetoWithIdusuarioOnly = await prisma.usuario_projeto.findMany({ select: { idusuario: true } })
     * 
     */
    findMany<T extends usuario_projetoFindManyArgs>(args?: SelectSubset<T, usuario_projetoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario_projeto.
     * @param {usuario_projetoCreateArgs} args - Arguments to create a Usuario_projeto.
     * @example
     * // Create one Usuario_projeto
     * const Usuario_projeto = await prisma.usuario_projeto.create({
     *   data: {
     *     // ... data to create a Usuario_projeto
     *   }
     * })
     * 
     */
    create<T extends usuario_projetoCreateArgs>(args: SelectSubset<T, usuario_projetoCreateArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuario_projetos.
     * @param {usuario_projetoCreateManyArgs} args - Arguments to create many Usuario_projetos.
     * @example
     * // Create many Usuario_projetos
     * const usuario_projeto = await prisma.usuario_projeto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usuario_projetoCreateManyArgs>(args?: SelectSubset<T, usuario_projetoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuario_projeto.
     * @param {usuario_projetoDeleteArgs} args - Arguments to delete one Usuario_projeto.
     * @example
     * // Delete one Usuario_projeto
     * const Usuario_projeto = await prisma.usuario_projeto.delete({
     *   where: {
     *     // ... filter to delete one Usuario_projeto
     *   }
     * })
     * 
     */
    delete<T extends usuario_projetoDeleteArgs>(args: SelectSubset<T, usuario_projetoDeleteArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario_projeto.
     * @param {usuario_projetoUpdateArgs} args - Arguments to update one Usuario_projeto.
     * @example
     * // Update one Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usuario_projetoUpdateArgs>(args: SelectSubset<T, usuario_projetoUpdateArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuario_projetos.
     * @param {usuario_projetoDeleteManyArgs} args - Arguments to filter Usuario_projetos to delete.
     * @example
     * // Delete a few Usuario_projetos
     * const { count } = await prisma.usuario_projeto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usuario_projetoDeleteManyArgs>(args?: SelectSubset<T, usuario_projetoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuario_projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuario_projetos
     * const usuario_projeto = await prisma.usuario_projeto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usuario_projetoUpdateManyArgs>(args: SelectSubset<T, usuario_projetoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario_projeto.
     * @param {usuario_projetoUpsertArgs} args - Arguments to update or create a Usuario_projeto.
     * @example
     * // Update or create a Usuario_projeto
     * const usuario_projeto = await prisma.usuario_projeto.upsert({
     *   create: {
     *     // ... data to create a Usuario_projeto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario_projeto we want to update
     *   }
     * })
     */
    upsert<T extends usuario_projetoUpsertArgs>(args: SelectSubset<T, usuario_projetoUpsertArgs<ExtArgs>>): Prisma__usuario_projetoClient<$Result.GetResult<Prisma.$usuario_projetoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuario_projetos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoCountArgs} args - Arguments to filter Usuario_projetos to count.
     * @example
     * // Count the number of Usuario_projetos
     * const count = await prisma.usuario_projeto.count({
     *   where: {
     *     // ... the filter for the Usuario_projetos we want to count
     *   }
     * })
    **/
    count<T extends usuario_projetoCountArgs>(
      args?: Subset<T, usuario_projetoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Usuario_projetoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario_projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Usuario_projetoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Usuario_projetoAggregateArgs>(args: Subset<T, Usuario_projetoAggregateArgs>): Prisma.PrismaPromise<GetUsuario_projetoAggregateType<T>>

    /**
     * Group by Usuario_projeto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usuario_projetoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usuario_projetoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usuario_projetoGroupByArgs['orderBy'] }
        : { orderBy?: usuario_projetoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usuario_projetoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuario_projetoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the usuario_projeto model
   */
  readonly fields: usuario_projetoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for usuario_projeto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usuario_projetoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    projeto<T extends projetoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, projetoDefaultArgs<ExtArgs>>): Prisma__projetoClient<$Result.GetResult<Prisma.$projetoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the usuario_projeto model
   */ 
  interface usuario_projetoFieldRefs {
    readonly idusuario: FieldRef<"usuario_projeto", 'Int'>
    readonly idprojeto: FieldRef<"usuario_projeto", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * usuario_projeto findUnique
   */
  export type usuario_projetoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter, which usuario_projeto to fetch.
     */
    where: usuario_projetoWhereUniqueInput
  }

  /**
   * usuario_projeto findUniqueOrThrow
   */
  export type usuario_projetoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter, which usuario_projeto to fetch.
     */
    where: usuario_projetoWhereUniqueInput
  }

  /**
   * usuario_projeto findFirst
   */
  export type usuario_projetoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter, which usuario_projeto to fetch.
     */
    where?: usuario_projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_projetos to fetch.
     */
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_projetos.
     */
    cursor?: usuario_projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_projetos.
     */
    distinct?: Usuario_projetoScalarFieldEnum | Usuario_projetoScalarFieldEnum[]
  }

  /**
   * usuario_projeto findFirstOrThrow
   */
  export type usuario_projetoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter, which usuario_projeto to fetch.
     */
    where?: usuario_projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_projetos to fetch.
     */
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for usuario_projetos.
     */
    cursor?: usuario_projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_projetos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of usuario_projetos.
     */
    distinct?: Usuario_projetoScalarFieldEnum | Usuario_projetoScalarFieldEnum[]
  }

  /**
   * usuario_projeto findMany
   */
  export type usuario_projetoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter, which usuario_projetos to fetch.
     */
    where?: usuario_projetoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of usuario_projetos to fetch.
     */
    orderBy?: usuario_projetoOrderByWithRelationInput | usuario_projetoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing usuario_projetos.
     */
    cursor?: usuario_projetoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` usuario_projetos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` usuario_projetos.
     */
    skip?: number
    distinct?: Usuario_projetoScalarFieldEnum | Usuario_projetoScalarFieldEnum[]
  }

  /**
   * usuario_projeto create
   */
  export type usuario_projetoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * The data needed to create a usuario_projeto.
     */
    data: XOR<usuario_projetoCreateInput, usuario_projetoUncheckedCreateInput>
  }

  /**
   * usuario_projeto createMany
   */
  export type usuario_projetoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many usuario_projetos.
     */
    data: usuario_projetoCreateManyInput | usuario_projetoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * usuario_projeto update
   */
  export type usuario_projetoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * The data needed to update a usuario_projeto.
     */
    data: XOR<usuario_projetoUpdateInput, usuario_projetoUncheckedUpdateInput>
    /**
     * Choose, which usuario_projeto to update.
     */
    where: usuario_projetoWhereUniqueInput
  }

  /**
   * usuario_projeto updateMany
   */
  export type usuario_projetoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update usuario_projetos.
     */
    data: XOR<usuario_projetoUpdateManyMutationInput, usuario_projetoUncheckedUpdateManyInput>
    /**
     * Filter which usuario_projetos to update
     */
    where?: usuario_projetoWhereInput
  }

  /**
   * usuario_projeto upsert
   */
  export type usuario_projetoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * The filter to search for the usuario_projeto to update in case it exists.
     */
    where: usuario_projetoWhereUniqueInput
    /**
     * In case the usuario_projeto found by the `where` argument doesn't exist, create a new usuario_projeto with this data.
     */
    create: XOR<usuario_projetoCreateInput, usuario_projetoUncheckedCreateInput>
    /**
     * In case the usuario_projeto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usuario_projetoUpdateInput, usuario_projetoUncheckedUpdateInput>
  }

  /**
   * usuario_projeto delete
   */
  export type usuario_projetoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
    /**
     * Filter which usuario_projeto to delete.
     */
    where: usuario_projetoWhereUniqueInput
  }

  /**
   * usuario_projeto deleteMany
   */
  export type usuario_projetoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which usuario_projetos to delete
     */
    where?: usuario_projetoWhereInput
  }

  /**
   * usuario_projeto without action
   */
  export type usuario_projetoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario_projeto
     */
    select?: usuario_projetoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuario_projetoInclude<ExtArgs> | null
  }


  /**
   * Model responsavel_tarefa
   */

  export type AggregateResponsavel_tarefa = {
    _count: Responsavel_tarefaCountAggregateOutputType | null
    _avg: Responsavel_tarefaAvgAggregateOutputType | null
    _sum: Responsavel_tarefaSumAggregateOutputType | null
    _min: Responsavel_tarefaMinAggregateOutputType | null
    _max: Responsavel_tarefaMaxAggregateOutputType | null
  }

  export type Responsavel_tarefaAvgAggregateOutputType = {
    id_usuario: number | null
    id_tarefa: number | null
  }

  export type Responsavel_tarefaSumAggregateOutputType = {
    id_usuario: number | null
    id_tarefa: number | null
  }

  export type Responsavel_tarefaMinAggregateOutputType = {
    id_usuario: number | null
    id_tarefa: number | null
  }

  export type Responsavel_tarefaMaxAggregateOutputType = {
    id_usuario: number | null
    id_tarefa: number | null
  }

  export type Responsavel_tarefaCountAggregateOutputType = {
    id_usuario: number
    id_tarefa: number
    _all: number
  }


  export type Responsavel_tarefaAvgAggregateInputType = {
    id_usuario?: true
    id_tarefa?: true
  }

  export type Responsavel_tarefaSumAggregateInputType = {
    id_usuario?: true
    id_tarefa?: true
  }

  export type Responsavel_tarefaMinAggregateInputType = {
    id_usuario?: true
    id_tarefa?: true
  }

  export type Responsavel_tarefaMaxAggregateInputType = {
    id_usuario?: true
    id_tarefa?: true
  }

  export type Responsavel_tarefaCountAggregateInputType = {
    id_usuario?: true
    id_tarefa?: true
    _all?: true
  }

  export type Responsavel_tarefaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsavel_tarefa to aggregate.
     */
    where?: responsavel_tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsavel_tarefas to fetch.
     */
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: responsavel_tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsavel_tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsavel_tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned responsavel_tarefas
    **/
    _count?: true | Responsavel_tarefaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Responsavel_tarefaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Responsavel_tarefaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Responsavel_tarefaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Responsavel_tarefaMaxAggregateInputType
  }

  export type GetResponsavel_tarefaAggregateType<T extends Responsavel_tarefaAggregateArgs> = {
        [P in keyof T & keyof AggregateResponsavel_tarefa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponsavel_tarefa[P]>
      : GetScalarType<T[P], AggregateResponsavel_tarefa[P]>
  }




  export type responsavel_tarefaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: responsavel_tarefaWhereInput
    orderBy?: responsavel_tarefaOrderByWithAggregationInput | responsavel_tarefaOrderByWithAggregationInput[]
    by: Responsavel_tarefaScalarFieldEnum[] | Responsavel_tarefaScalarFieldEnum
    having?: responsavel_tarefaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Responsavel_tarefaCountAggregateInputType | true
    _avg?: Responsavel_tarefaAvgAggregateInputType
    _sum?: Responsavel_tarefaSumAggregateInputType
    _min?: Responsavel_tarefaMinAggregateInputType
    _max?: Responsavel_tarefaMaxAggregateInputType
  }

  export type Responsavel_tarefaGroupByOutputType = {
    id_usuario: number
    id_tarefa: number
    _count: Responsavel_tarefaCountAggregateOutputType | null
    _avg: Responsavel_tarefaAvgAggregateOutputType | null
    _sum: Responsavel_tarefaSumAggregateOutputType | null
    _min: Responsavel_tarefaMinAggregateOutputType | null
    _max: Responsavel_tarefaMaxAggregateOutputType | null
  }

  type GetResponsavel_tarefaGroupByPayload<T extends responsavel_tarefaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Responsavel_tarefaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Responsavel_tarefaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Responsavel_tarefaGroupByOutputType[P]>
            : GetScalarType<T[P], Responsavel_tarefaGroupByOutputType[P]>
        }
      >
    >


  export type responsavel_tarefaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_usuario?: boolean
    id_tarefa?: boolean
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["responsavel_tarefa"]>


  export type responsavel_tarefaSelectScalar = {
    id_usuario?: boolean
    id_tarefa?: boolean
  }

  export type responsavel_tarefaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | usuarioDefaultArgs<ExtArgs>
    tarefa?: boolean | tarefaDefaultArgs<ExtArgs>
  }

  export type $responsavel_tarefaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "responsavel_tarefa"
    objects: {
      usuario: Prisma.$usuarioPayload<ExtArgs>
      tarefa: Prisma.$tarefaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_usuario: number
      id_tarefa: number
    }, ExtArgs["result"]["responsavel_tarefa"]>
    composites: {}
  }

  type responsavel_tarefaGetPayload<S extends boolean | null | undefined | responsavel_tarefaDefaultArgs> = $Result.GetResult<Prisma.$responsavel_tarefaPayload, S>

  type responsavel_tarefaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<responsavel_tarefaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Responsavel_tarefaCountAggregateInputType | true
    }

  export interface responsavel_tarefaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['responsavel_tarefa'], meta: { name: 'responsavel_tarefa' } }
    /**
     * Find zero or one Responsavel_tarefa that matches the filter.
     * @param {responsavel_tarefaFindUniqueArgs} args - Arguments to find a Responsavel_tarefa
     * @example
     * // Get one Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends responsavel_tarefaFindUniqueArgs>(args: SelectSubset<T, responsavel_tarefaFindUniqueArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Responsavel_tarefa that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {responsavel_tarefaFindUniqueOrThrowArgs} args - Arguments to find a Responsavel_tarefa
     * @example
     * // Get one Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends responsavel_tarefaFindUniqueOrThrowArgs>(args: SelectSubset<T, responsavel_tarefaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Responsavel_tarefa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaFindFirstArgs} args - Arguments to find a Responsavel_tarefa
     * @example
     * // Get one Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends responsavel_tarefaFindFirstArgs>(args?: SelectSubset<T, responsavel_tarefaFindFirstArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Responsavel_tarefa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaFindFirstOrThrowArgs} args - Arguments to find a Responsavel_tarefa
     * @example
     * // Get one Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends responsavel_tarefaFindFirstOrThrowArgs>(args?: SelectSubset<T, responsavel_tarefaFindFirstOrThrowArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Responsavel_tarefas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responsavel_tarefas
     * const responsavel_tarefas = await prisma.responsavel_tarefa.findMany()
     * 
     * // Get first 10 Responsavel_tarefas
     * const responsavel_tarefas = await prisma.responsavel_tarefa.findMany({ take: 10 })
     * 
     * // Only select the `id_usuario`
     * const responsavel_tarefaWithId_usuarioOnly = await prisma.responsavel_tarefa.findMany({ select: { id_usuario: true } })
     * 
     */
    findMany<T extends responsavel_tarefaFindManyArgs>(args?: SelectSubset<T, responsavel_tarefaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Responsavel_tarefa.
     * @param {responsavel_tarefaCreateArgs} args - Arguments to create a Responsavel_tarefa.
     * @example
     * // Create one Responsavel_tarefa
     * const Responsavel_tarefa = await prisma.responsavel_tarefa.create({
     *   data: {
     *     // ... data to create a Responsavel_tarefa
     *   }
     * })
     * 
     */
    create<T extends responsavel_tarefaCreateArgs>(args: SelectSubset<T, responsavel_tarefaCreateArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Responsavel_tarefas.
     * @param {responsavel_tarefaCreateManyArgs} args - Arguments to create many Responsavel_tarefas.
     * @example
     * // Create many Responsavel_tarefas
     * const responsavel_tarefa = await prisma.responsavel_tarefa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends responsavel_tarefaCreateManyArgs>(args?: SelectSubset<T, responsavel_tarefaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Responsavel_tarefa.
     * @param {responsavel_tarefaDeleteArgs} args - Arguments to delete one Responsavel_tarefa.
     * @example
     * // Delete one Responsavel_tarefa
     * const Responsavel_tarefa = await prisma.responsavel_tarefa.delete({
     *   where: {
     *     // ... filter to delete one Responsavel_tarefa
     *   }
     * })
     * 
     */
    delete<T extends responsavel_tarefaDeleteArgs>(args: SelectSubset<T, responsavel_tarefaDeleteArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Responsavel_tarefa.
     * @param {responsavel_tarefaUpdateArgs} args - Arguments to update one Responsavel_tarefa.
     * @example
     * // Update one Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends responsavel_tarefaUpdateArgs>(args: SelectSubset<T, responsavel_tarefaUpdateArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Responsavel_tarefas.
     * @param {responsavel_tarefaDeleteManyArgs} args - Arguments to filter Responsavel_tarefas to delete.
     * @example
     * // Delete a few Responsavel_tarefas
     * const { count } = await prisma.responsavel_tarefa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends responsavel_tarefaDeleteManyArgs>(args?: SelectSubset<T, responsavel_tarefaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responsavel_tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responsavel_tarefas
     * const responsavel_tarefa = await prisma.responsavel_tarefa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends responsavel_tarefaUpdateManyArgs>(args: SelectSubset<T, responsavel_tarefaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Responsavel_tarefa.
     * @param {responsavel_tarefaUpsertArgs} args - Arguments to update or create a Responsavel_tarefa.
     * @example
     * // Update or create a Responsavel_tarefa
     * const responsavel_tarefa = await prisma.responsavel_tarefa.upsert({
     *   create: {
     *     // ... data to create a Responsavel_tarefa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Responsavel_tarefa we want to update
     *   }
     * })
     */
    upsert<T extends responsavel_tarefaUpsertArgs>(args: SelectSubset<T, responsavel_tarefaUpsertArgs<ExtArgs>>): Prisma__responsavel_tarefaClient<$Result.GetResult<Prisma.$responsavel_tarefaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Responsavel_tarefas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaCountArgs} args - Arguments to filter Responsavel_tarefas to count.
     * @example
     * // Count the number of Responsavel_tarefas
     * const count = await prisma.responsavel_tarefa.count({
     *   where: {
     *     // ... the filter for the Responsavel_tarefas we want to count
     *   }
     * })
    **/
    count<T extends responsavel_tarefaCountArgs>(
      args?: Subset<T, responsavel_tarefaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Responsavel_tarefaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Responsavel_tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Responsavel_tarefaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Responsavel_tarefaAggregateArgs>(args: Subset<T, Responsavel_tarefaAggregateArgs>): Prisma.PrismaPromise<GetResponsavel_tarefaAggregateType<T>>

    /**
     * Group by Responsavel_tarefa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {responsavel_tarefaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends responsavel_tarefaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: responsavel_tarefaGroupByArgs['orderBy'] }
        : { orderBy?: responsavel_tarefaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, responsavel_tarefaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponsavel_tarefaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the responsavel_tarefa model
   */
  readonly fields: responsavel_tarefaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for responsavel_tarefa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__responsavel_tarefaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends usuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usuarioDefaultArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tarefa<T extends tarefaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tarefaDefaultArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the responsavel_tarefa model
   */ 
  interface responsavel_tarefaFieldRefs {
    readonly id_usuario: FieldRef<"responsavel_tarefa", 'Int'>
    readonly id_tarefa: FieldRef<"responsavel_tarefa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * responsavel_tarefa findUnique
   */
  export type responsavel_tarefaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter, which responsavel_tarefa to fetch.
     */
    where: responsavel_tarefaWhereUniqueInput
  }

  /**
   * responsavel_tarefa findUniqueOrThrow
   */
  export type responsavel_tarefaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter, which responsavel_tarefa to fetch.
     */
    where: responsavel_tarefaWhereUniqueInput
  }

  /**
   * responsavel_tarefa findFirst
   */
  export type responsavel_tarefaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter, which responsavel_tarefa to fetch.
     */
    where?: responsavel_tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsavel_tarefas to fetch.
     */
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsavel_tarefas.
     */
    cursor?: responsavel_tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsavel_tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsavel_tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsavel_tarefas.
     */
    distinct?: Responsavel_tarefaScalarFieldEnum | Responsavel_tarefaScalarFieldEnum[]
  }

  /**
   * responsavel_tarefa findFirstOrThrow
   */
  export type responsavel_tarefaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter, which responsavel_tarefa to fetch.
     */
    where?: responsavel_tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsavel_tarefas to fetch.
     */
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for responsavel_tarefas.
     */
    cursor?: responsavel_tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsavel_tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsavel_tarefas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of responsavel_tarefas.
     */
    distinct?: Responsavel_tarefaScalarFieldEnum | Responsavel_tarefaScalarFieldEnum[]
  }

  /**
   * responsavel_tarefa findMany
   */
  export type responsavel_tarefaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter, which responsavel_tarefas to fetch.
     */
    where?: responsavel_tarefaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of responsavel_tarefas to fetch.
     */
    orderBy?: responsavel_tarefaOrderByWithRelationInput | responsavel_tarefaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing responsavel_tarefas.
     */
    cursor?: responsavel_tarefaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` responsavel_tarefas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` responsavel_tarefas.
     */
    skip?: number
    distinct?: Responsavel_tarefaScalarFieldEnum | Responsavel_tarefaScalarFieldEnum[]
  }

  /**
   * responsavel_tarefa create
   */
  export type responsavel_tarefaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * The data needed to create a responsavel_tarefa.
     */
    data: XOR<responsavel_tarefaCreateInput, responsavel_tarefaUncheckedCreateInput>
  }

  /**
   * responsavel_tarefa createMany
   */
  export type responsavel_tarefaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many responsavel_tarefas.
     */
    data: responsavel_tarefaCreateManyInput | responsavel_tarefaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * responsavel_tarefa update
   */
  export type responsavel_tarefaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * The data needed to update a responsavel_tarefa.
     */
    data: XOR<responsavel_tarefaUpdateInput, responsavel_tarefaUncheckedUpdateInput>
    /**
     * Choose, which responsavel_tarefa to update.
     */
    where: responsavel_tarefaWhereUniqueInput
  }

  /**
   * responsavel_tarefa updateMany
   */
  export type responsavel_tarefaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update responsavel_tarefas.
     */
    data: XOR<responsavel_tarefaUpdateManyMutationInput, responsavel_tarefaUncheckedUpdateManyInput>
    /**
     * Filter which responsavel_tarefas to update
     */
    where?: responsavel_tarefaWhereInput
  }

  /**
   * responsavel_tarefa upsert
   */
  export type responsavel_tarefaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * The filter to search for the responsavel_tarefa to update in case it exists.
     */
    where: responsavel_tarefaWhereUniqueInput
    /**
     * In case the responsavel_tarefa found by the `where` argument doesn't exist, create a new responsavel_tarefa with this data.
     */
    create: XOR<responsavel_tarefaCreateInput, responsavel_tarefaUncheckedCreateInput>
    /**
     * In case the responsavel_tarefa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<responsavel_tarefaUpdateInput, responsavel_tarefaUncheckedUpdateInput>
  }

  /**
   * responsavel_tarefa delete
   */
  export type responsavel_tarefaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
    /**
     * Filter which responsavel_tarefa to delete.
     */
    where: responsavel_tarefaWhereUniqueInput
  }

  /**
   * responsavel_tarefa deleteMany
   */
  export type responsavel_tarefaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which responsavel_tarefas to delete
     */
    where?: responsavel_tarefaWhereInput
  }

  /**
   * responsavel_tarefa without action
   */
  export type responsavel_tarefaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the responsavel_tarefa
     */
    select?: responsavel_tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: responsavel_tarefaInclude<ExtArgs> | null
  }


  /**
   * Model comentario
   */

  export type AggregateComentario = {
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  export type ComentarioAvgAggregateOutputType = {
    idcomentario: number | null
    id_tarefa: number | null
    id_usuario: number | null
  }

  export type ComentarioSumAggregateOutputType = {
    idcomentario: number | null
    id_tarefa: number | null
    id_usuario: number | null
  }

  export type ComentarioMinAggregateOutputType = {
    idcomentario: number | null
    texto: string | null
    id_tarefa: number | null
    id_usuario: number | null
  }

  export type ComentarioMaxAggregateOutputType = {
    idcomentario: number | null
    texto: string | null
    id_tarefa: number | null
    id_usuario: number | null
  }

  export type ComentarioCountAggregateOutputType = {
    idcomentario: number
    texto: number
    id_tarefa: number
    id_usuario: number
    _all: number
  }


  export type ComentarioAvgAggregateInputType = {
    idcomentario?: true
    id_tarefa?: true
    id_usuario?: true
  }

  export type ComentarioSumAggregateInputType = {
    idcomentario?: true
    id_tarefa?: true
    id_usuario?: true
  }

  export type ComentarioMinAggregateInputType = {
    idcomentario?: true
    texto?: true
    id_tarefa?: true
    id_usuario?: true
  }

  export type ComentarioMaxAggregateInputType = {
    idcomentario?: true
    texto?: true
    id_tarefa?: true
    id_usuario?: true
  }

  export type ComentarioCountAggregateInputType = {
    idcomentario?: true
    texto?: true
    id_tarefa?: true
    id_usuario?: true
    _all?: true
  }

  export type ComentarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentario to aggregate.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comentarios
    **/
    _count?: true | ComentarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComentarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComentarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComentarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComentarioMaxAggregateInputType
  }

  export type GetComentarioAggregateType<T extends ComentarioAggregateArgs> = {
        [P in keyof T & keyof AggregateComentario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComentario[P]>
      : GetScalarType<T[P], AggregateComentario[P]>
  }




  export type comentarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comentarioWhereInput
    orderBy?: comentarioOrderByWithAggregationInput | comentarioOrderByWithAggregationInput[]
    by: ComentarioScalarFieldEnum[] | ComentarioScalarFieldEnum
    having?: comentarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComentarioCountAggregateInputType | true
    _avg?: ComentarioAvgAggregateInputType
    _sum?: ComentarioSumAggregateInputType
    _min?: ComentarioMinAggregateInputType
    _max?: ComentarioMaxAggregateInputType
  }

  export type ComentarioGroupByOutputType = {
    idcomentario: number
    texto: string | null
    id_tarefa: number | null
    id_usuario: number | null
    _count: ComentarioCountAggregateOutputType | null
    _avg: ComentarioAvgAggregateOutputType | null
    _sum: ComentarioSumAggregateOutputType | null
    _min: ComentarioMinAggregateOutputType | null
    _max: ComentarioMaxAggregateOutputType | null
  }

  type GetComentarioGroupByPayload<T extends comentarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComentarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComentarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
            : GetScalarType<T[P], ComentarioGroupByOutputType[P]>
        }
      >
    >


  export type comentarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcomentario?: boolean
    texto?: boolean
    id_tarefa?: boolean
    id_usuario?: boolean
    tarefa?: boolean | comentario$tarefaArgs<ExtArgs>
    usuario?: boolean | comentario$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["comentario"]>


  export type comentarioSelectScalar = {
    idcomentario?: boolean
    texto?: boolean
    id_tarefa?: boolean
    id_usuario?: boolean
  }

  export type comentarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tarefa?: boolean | comentario$tarefaArgs<ExtArgs>
    usuario?: boolean | comentario$usuarioArgs<ExtArgs>
  }

  export type $comentarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comentario"
    objects: {
      tarefa: Prisma.$tarefaPayload<ExtArgs> | null
      usuario: Prisma.$usuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idcomentario: number
      texto: string | null
      id_tarefa: number | null
      id_usuario: number | null
    }, ExtArgs["result"]["comentario"]>
    composites: {}
  }

  type comentarioGetPayload<S extends boolean | null | undefined | comentarioDefaultArgs> = $Result.GetResult<Prisma.$comentarioPayload, S>

  type comentarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comentarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComentarioCountAggregateInputType | true
    }

  export interface comentarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comentario'], meta: { name: 'comentario' } }
    /**
     * Find zero or one Comentario that matches the filter.
     * @param {comentarioFindUniqueArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comentarioFindUniqueArgs>(args: SelectSubset<T, comentarioFindUniqueArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comentario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {comentarioFindUniqueOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comentarioFindUniqueOrThrowArgs>(args: SelectSubset<T, comentarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comentario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindFirstArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comentarioFindFirstArgs>(args?: SelectSubset<T, comentarioFindFirstArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comentario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindFirstOrThrowArgs} args - Arguments to find a Comentario
     * @example
     * // Get one Comentario
     * const comentario = await prisma.comentario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comentarioFindFirstOrThrowArgs>(args?: SelectSubset<T, comentarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comentarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comentarios
     * const comentarios = await prisma.comentario.findMany()
     * 
     * // Get first 10 Comentarios
     * const comentarios = await prisma.comentario.findMany({ take: 10 })
     * 
     * // Only select the `idcomentario`
     * const comentarioWithIdcomentarioOnly = await prisma.comentario.findMany({ select: { idcomentario: true } })
     * 
     */
    findMany<T extends comentarioFindManyArgs>(args?: SelectSubset<T, comentarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comentario.
     * @param {comentarioCreateArgs} args - Arguments to create a Comentario.
     * @example
     * // Create one Comentario
     * const Comentario = await prisma.comentario.create({
     *   data: {
     *     // ... data to create a Comentario
     *   }
     * })
     * 
     */
    create<T extends comentarioCreateArgs>(args: SelectSubset<T, comentarioCreateArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comentarios.
     * @param {comentarioCreateManyArgs} args - Arguments to create many Comentarios.
     * @example
     * // Create many Comentarios
     * const comentario = await prisma.comentario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comentarioCreateManyArgs>(args?: SelectSubset<T, comentarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comentario.
     * @param {comentarioDeleteArgs} args - Arguments to delete one Comentario.
     * @example
     * // Delete one Comentario
     * const Comentario = await prisma.comentario.delete({
     *   where: {
     *     // ... filter to delete one Comentario
     *   }
     * })
     * 
     */
    delete<T extends comentarioDeleteArgs>(args: SelectSubset<T, comentarioDeleteArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comentario.
     * @param {comentarioUpdateArgs} args - Arguments to update one Comentario.
     * @example
     * // Update one Comentario
     * const comentario = await prisma.comentario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comentarioUpdateArgs>(args: SelectSubset<T, comentarioUpdateArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comentarios.
     * @param {comentarioDeleteManyArgs} args - Arguments to filter Comentarios to delete.
     * @example
     * // Delete a few Comentarios
     * const { count } = await prisma.comentario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comentarioDeleteManyArgs>(args?: SelectSubset<T, comentarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comentarios
     * const comentario = await prisma.comentario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comentarioUpdateManyArgs>(args: SelectSubset<T, comentarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comentario.
     * @param {comentarioUpsertArgs} args - Arguments to update or create a Comentario.
     * @example
     * // Update or create a Comentario
     * const comentario = await prisma.comentario.upsert({
     *   create: {
     *     // ... data to create a Comentario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comentario we want to update
     *   }
     * })
     */
    upsert<T extends comentarioUpsertArgs>(args: SelectSubset<T, comentarioUpsertArgs<ExtArgs>>): Prisma__comentarioClient<$Result.GetResult<Prisma.$comentarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comentarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioCountArgs} args - Arguments to filter Comentarios to count.
     * @example
     * // Count the number of Comentarios
     * const count = await prisma.comentario.count({
     *   where: {
     *     // ... the filter for the Comentarios we want to count
     *   }
     * })
    **/
    count<T extends comentarioCountArgs>(
      args?: Subset<T, comentarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComentarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComentarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComentarioAggregateArgs>(args: Subset<T, ComentarioAggregateArgs>): Prisma.PrismaPromise<GetComentarioAggregateType<T>>

    /**
     * Group by Comentario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comentarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comentarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comentarioGroupByArgs['orderBy'] }
        : { orderBy?: comentarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comentarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComentarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comentario model
   */
  readonly fields: comentarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comentario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comentarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tarefa<T extends comentario$tarefaArgs<ExtArgs> = {}>(args?: Subset<T, comentario$tarefaArgs<ExtArgs>>): Prisma__tarefaClient<$Result.GetResult<Prisma.$tarefaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usuario<T extends comentario$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, comentario$usuarioArgs<ExtArgs>>): Prisma__usuarioClient<$Result.GetResult<Prisma.$usuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comentario model
   */ 
  interface comentarioFieldRefs {
    readonly idcomentario: FieldRef<"comentario", 'Int'>
    readonly texto: FieldRef<"comentario", 'String'>
    readonly id_tarefa: FieldRef<"comentario", 'Int'>
    readonly id_usuario: FieldRef<"comentario", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * comentario findUnique
   */
  export type comentarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario findUniqueOrThrow
   */
  export type comentarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario findFirst
   */
  export type comentarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario findFirstOrThrow
   */
  export type comentarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentario to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comentarios.
     */
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario findMany
   */
  export type comentarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter, which comentarios to fetch.
     */
    where?: comentarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comentarios to fetch.
     */
    orderBy?: comentarioOrderByWithRelationInput | comentarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comentarios.
     */
    cursor?: comentarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comentarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comentarios.
     */
    skip?: number
    distinct?: ComentarioScalarFieldEnum | ComentarioScalarFieldEnum[]
  }

  /**
   * comentario create
   */
  export type comentarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The data needed to create a comentario.
     */
    data?: XOR<comentarioCreateInput, comentarioUncheckedCreateInput>
  }

  /**
   * comentario createMany
   */
  export type comentarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comentarios.
     */
    data: comentarioCreateManyInput | comentarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comentario update
   */
  export type comentarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The data needed to update a comentario.
     */
    data: XOR<comentarioUpdateInput, comentarioUncheckedUpdateInput>
    /**
     * Choose, which comentario to update.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario updateMany
   */
  export type comentarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comentarios.
     */
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyInput>
    /**
     * Filter which comentarios to update
     */
    where?: comentarioWhereInput
  }

  /**
   * comentario upsert
   */
  export type comentarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * The filter to search for the comentario to update in case it exists.
     */
    where: comentarioWhereUniqueInput
    /**
     * In case the comentario found by the `where` argument doesn't exist, create a new comentario with this data.
     */
    create: XOR<comentarioCreateInput, comentarioUncheckedCreateInput>
    /**
     * In case the comentario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comentarioUpdateInput, comentarioUncheckedUpdateInput>
  }

  /**
   * comentario delete
   */
  export type comentarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
    /**
     * Filter which comentario to delete.
     */
    where: comentarioWhereUniqueInput
  }

  /**
   * comentario deleteMany
   */
  export type comentarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comentarios to delete
     */
    where?: comentarioWhereInput
  }

  /**
   * comentario.tarefa
   */
  export type comentario$tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tarefa
     */
    select?: tarefaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tarefaInclude<ExtArgs> | null
    where?: tarefaWhereInput
  }

  /**
   * comentario.usuario
   */
  export type comentario$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the usuario
     */
    select?: usuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usuarioInclude<ExtArgs> | null
    where?: usuarioWhereInput
  }

  /**
   * comentario without action
   */
  export type comentarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comentario
     */
    select?: comentarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comentarioInclude<ExtArgs> | null
  }


  /**
   * Model todo
   */

  export type AggregateTodo = {
    _count: TodoCountAggregateOutputType | null
    _avg: TodoAvgAggregateOutputType | null
    _sum: TodoSumAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  export type TodoAvgAggregateOutputType = {
    IDTODO: number | null
  }

  export type TodoSumAggregateOutputType = {
    IDTODO: number | null
  }

  export type TodoMinAggregateOutputType = {
    IDTODO: number | null
    TITLE: string | null
    DESCRIPTION: string | null
  }

  export type TodoMaxAggregateOutputType = {
    IDTODO: number | null
    TITLE: string | null
    DESCRIPTION: string | null
  }

  export type TodoCountAggregateOutputType = {
    IDTODO: number
    TITLE: number
    DESCRIPTION: number
    _all: number
  }


  export type TodoAvgAggregateInputType = {
    IDTODO?: true
  }

  export type TodoSumAggregateInputType = {
    IDTODO?: true
  }

  export type TodoMinAggregateInputType = {
    IDTODO?: true
    TITLE?: true
    DESCRIPTION?: true
  }

  export type TodoMaxAggregateInputType = {
    IDTODO?: true
    TITLE?: true
    DESCRIPTION?: true
  }

  export type TodoCountAggregateInputType = {
    IDTODO?: true
    TITLE?: true
    DESCRIPTION?: true
    _all?: true
  }

  export type TodoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which todo to aggregate.
     */
    where?: todoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of todos to fetch.
     */
    orderBy?: todoOrderByWithRelationInput | todoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: todoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned todos
    **/
    _count?: true | TodoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TodoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TodoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoMaxAggregateInputType
  }

  export type GetTodoAggregateType<T extends TodoAggregateArgs> = {
        [P in keyof T & keyof AggregateTodo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodo[P]>
      : GetScalarType<T[P], AggregateTodo[P]>
  }




  export type todoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: todoWhereInput
    orderBy?: todoOrderByWithAggregationInput | todoOrderByWithAggregationInput[]
    by: TodoScalarFieldEnum[] | TodoScalarFieldEnum
    having?: todoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoCountAggregateInputType | true
    _avg?: TodoAvgAggregateInputType
    _sum?: TodoSumAggregateInputType
    _min?: TodoMinAggregateInputType
    _max?: TodoMaxAggregateInputType
  }

  export type TodoGroupByOutputType = {
    IDTODO: number
    TITLE: string
    DESCRIPTION: string
    _count: TodoCountAggregateOutputType | null
    _avg: TodoAvgAggregateOutputType | null
    _sum: TodoSumAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  type GetTodoGroupByPayload<T extends todoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoGroupByOutputType[P]>
            : GetScalarType<T[P], TodoGroupByOutputType[P]>
        }
      >
    >


  export type todoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDTODO?: boolean
    TITLE?: boolean
    DESCRIPTION?: boolean
  }, ExtArgs["result"]["todo"]>


  export type todoSelectScalar = {
    IDTODO?: boolean
    TITLE?: boolean
    DESCRIPTION?: boolean
  }


  export type $todoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "todo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      IDTODO: number
      TITLE: string
      DESCRIPTION: string
    }, ExtArgs["result"]["todo"]>
    composites: {}
  }

  type todoGetPayload<S extends boolean | null | undefined | todoDefaultArgs> = $Result.GetResult<Prisma.$todoPayload, S>

  type todoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<todoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TodoCountAggregateInputType | true
    }

  export interface todoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['todo'], meta: { name: 'todo' } }
    /**
     * Find zero or one Todo that matches the filter.
     * @param {todoFindUniqueArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends todoFindUniqueArgs>(args: SelectSubset<T, todoFindUniqueArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Todo that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {todoFindUniqueOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends todoFindUniqueOrThrowArgs>(args: SelectSubset<T, todoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Todo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoFindFirstArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends todoFindFirstArgs>(args?: SelectSubset<T, todoFindFirstArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Todo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoFindFirstOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends todoFindFirstOrThrowArgs>(args?: SelectSubset<T, todoFindFirstOrThrowArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Todos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Todos
     * const todos = await prisma.todo.findMany()
     * 
     * // Get first 10 Todos
     * const todos = await prisma.todo.findMany({ take: 10 })
     * 
     * // Only select the `IDTODO`
     * const todoWithIDTODOOnly = await prisma.todo.findMany({ select: { IDTODO: true } })
     * 
     */
    findMany<T extends todoFindManyArgs>(args?: SelectSubset<T, todoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Todo.
     * @param {todoCreateArgs} args - Arguments to create a Todo.
     * @example
     * // Create one Todo
     * const Todo = await prisma.todo.create({
     *   data: {
     *     // ... data to create a Todo
     *   }
     * })
     * 
     */
    create<T extends todoCreateArgs>(args: SelectSubset<T, todoCreateArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Todos.
     * @param {todoCreateManyArgs} args - Arguments to create many Todos.
     * @example
     * // Create many Todos
     * const todo = await prisma.todo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends todoCreateManyArgs>(args?: SelectSubset<T, todoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Todo.
     * @param {todoDeleteArgs} args - Arguments to delete one Todo.
     * @example
     * // Delete one Todo
     * const Todo = await prisma.todo.delete({
     *   where: {
     *     // ... filter to delete one Todo
     *   }
     * })
     * 
     */
    delete<T extends todoDeleteArgs>(args: SelectSubset<T, todoDeleteArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Todo.
     * @param {todoUpdateArgs} args - Arguments to update one Todo.
     * @example
     * // Update one Todo
     * const todo = await prisma.todo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends todoUpdateArgs>(args: SelectSubset<T, todoUpdateArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Todos.
     * @param {todoDeleteManyArgs} args - Arguments to filter Todos to delete.
     * @example
     * // Delete a few Todos
     * const { count } = await prisma.todo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends todoDeleteManyArgs>(args?: SelectSubset<T, todoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends todoUpdateManyArgs>(args: SelectSubset<T, todoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Todo.
     * @param {todoUpsertArgs} args - Arguments to update or create a Todo.
     * @example
     * // Update or create a Todo
     * const todo = await prisma.todo.upsert({
     *   create: {
     *     // ... data to create a Todo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Todo we want to update
     *   }
     * })
     */
    upsert<T extends todoUpsertArgs>(args: SelectSubset<T, todoUpsertArgs<ExtArgs>>): Prisma__todoClient<$Result.GetResult<Prisma.$todoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoCountArgs} args - Arguments to filter Todos to count.
     * @example
     * // Count the number of Todos
     * const count = await prisma.todo.count({
     *   where: {
     *     // ... the filter for the Todos we want to count
     *   }
     * })
    **/
    count<T extends todoCountArgs>(
      args?: Subset<T, todoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoAggregateArgs>(args: Subset<T, TodoAggregateArgs>): Prisma.PrismaPromise<GetTodoAggregateType<T>>

    /**
     * Group by Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {todoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends todoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: todoGroupByArgs['orderBy'] }
        : { orderBy?: todoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, todoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the todo model
   */
  readonly fields: todoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for todo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__todoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the todo model
   */ 
  interface todoFieldRefs {
    readonly IDTODO: FieldRef<"todo", 'Int'>
    readonly TITLE: FieldRef<"todo", 'String'>
    readonly DESCRIPTION: FieldRef<"todo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * todo findUnique
   */
  export type todoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter, which todo to fetch.
     */
    where: todoWhereUniqueInput
  }

  /**
   * todo findUniqueOrThrow
   */
  export type todoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter, which todo to fetch.
     */
    where: todoWhereUniqueInput
  }

  /**
   * todo findFirst
   */
  export type todoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter, which todo to fetch.
     */
    where?: todoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of todos to fetch.
     */
    orderBy?: todoOrderByWithRelationInput | todoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for todos.
     */
    cursor?: todoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * todo findFirstOrThrow
   */
  export type todoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter, which todo to fetch.
     */
    where?: todoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of todos to fetch.
     */
    orderBy?: todoOrderByWithRelationInput | todoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for todos.
     */
    cursor?: todoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * todo findMany
   */
  export type todoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter, which todos to fetch.
     */
    where?: todoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of todos to fetch.
     */
    orderBy?: todoOrderByWithRelationInput | todoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing todos.
     */
    cursor?: todoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` todos.
     */
    skip?: number
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * todo create
   */
  export type todoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * The data needed to create a todo.
     */
    data: XOR<todoCreateInput, todoUncheckedCreateInput>
  }

  /**
   * todo createMany
   */
  export type todoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many todos.
     */
    data: todoCreateManyInput | todoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * todo update
   */
  export type todoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * The data needed to update a todo.
     */
    data: XOR<todoUpdateInput, todoUncheckedUpdateInput>
    /**
     * Choose, which todo to update.
     */
    where: todoWhereUniqueInput
  }

  /**
   * todo updateMany
   */
  export type todoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update todos.
     */
    data: XOR<todoUpdateManyMutationInput, todoUncheckedUpdateManyInput>
    /**
     * Filter which todos to update
     */
    where?: todoWhereInput
  }

  /**
   * todo upsert
   */
  export type todoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * The filter to search for the todo to update in case it exists.
     */
    where: todoWhereUniqueInput
    /**
     * In case the todo found by the `where` argument doesn't exist, create a new todo with this data.
     */
    create: XOR<todoCreateInput, todoUncheckedCreateInput>
    /**
     * In case the todo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<todoUpdateInput, todoUncheckedUpdateInput>
  }

  /**
   * todo delete
   */
  export type todoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
    /**
     * Filter which todo to delete.
     */
    where: todoWhereUniqueInput
  }

  /**
   * todo deleteMany
   */
  export type todoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which todos to delete
     */
    where?: todoWhereInput
  }

  /**
   * todo without action
   */
  export type todoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the todo
     */
    select?: todoSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    idusuario: 'idusuario',
    cpf: 'cpf',
    nome: 'nome',
    hash_senha: 'hash_senha',
    email: 'email',
    papel: 'papel',
    usuario_tipo: 'usuario_tipo'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ProjetoScalarFieldEnum: {
    idprojeto: 'idprojeto',
    nome: 'nome',
    valor: 'valor',
    data_inicio: 'data_inicio',
    prazo: 'prazo',
    status: 'status',
    descricao: 'descricao',
    foto: 'foto',
    id_gestor: 'id_gestor'
  };

  export type ProjetoScalarFieldEnum = (typeof ProjetoScalarFieldEnum)[keyof typeof ProjetoScalarFieldEnum]


  export const TarefaScalarFieldEnum: {
    idtarefa: 'idtarefa',
    nome: 'nome',
    data_inicio: 'data_inicio',
    prazo: 'prazo',
    status: 'status',
    descricao: 'descricao',
    id_projeto: 'id_projeto',
    id_gestor: 'id_gestor'
  };

  export type TarefaScalarFieldEnum = (typeof TarefaScalarFieldEnum)[keyof typeof TarefaScalarFieldEnum]


  export const Usuario_projetoScalarFieldEnum: {
    idusuario: 'idusuario',
    idprojeto: 'idprojeto'
  };

  export type Usuario_projetoScalarFieldEnum = (typeof Usuario_projetoScalarFieldEnum)[keyof typeof Usuario_projetoScalarFieldEnum]


  export const Responsavel_tarefaScalarFieldEnum: {
    id_usuario: 'id_usuario',
    id_tarefa: 'id_tarefa'
  };

  export type Responsavel_tarefaScalarFieldEnum = (typeof Responsavel_tarefaScalarFieldEnum)[keyof typeof Responsavel_tarefaScalarFieldEnum]


  export const ComentarioScalarFieldEnum: {
    idcomentario: 'idcomentario',
    texto: 'texto',
    id_tarefa: 'id_tarefa',
    id_usuario: 'id_usuario'
  };

  export type ComentarioScalarFieldEnum = (typeof ComentarioScalarFieldEnum)[keyof typeof ComentarioScalarFieldEnum]


  export const TodoScalarFieldEnum: {
    IDTODO: 'IDTODO',
    TITLE: 'TITLE',
    DESCRIPTION: 'DESCRIPTION'
  };

  export type TodoScalarFieldEnum = (typeof TodoScalarFieldEnum)[keyof typeof TodoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type usuarioWhereInput = {
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    idusuario?: IntFilter<"usuario"> | number
    cpf?: StringFilter<"usuario"> | string
    nome?: StringFilter<"usuario"> | string
    hash_senha?: StringFilter<"usuario"> | string
    email?: StringFilter<"usuario"> | string
    papel?: StringFilter<"usuario"> | string
    usuario_tipo?: IntFilter<"usuario"> | number
    projetos?: Usuario_projetoListRelationFilter
    tarefas?: TarefaListRelationFilter
    comentarios?: ComentarioListRelationFilter
    responsaveis?: Responsavel_tarefaListRelationFilter
    projetos_gestor?: ProjetoListRelationFilter
  }

  export type usuarioOrderByWithRelationInput = {
    idusuario?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    hash_senha?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    usuario_tipo?: SortOrder
    projetos?: usuario_projetoOrderByRelationAggregateInput
    tarefas?: tarefaOrderByRelationAggregateInput
    comentarios?: comentarioOrderByRelationAggregateInput
    responsaveis?: responsavel_tarefaOrderByRelationAggregateInput
    projetos_gestor?: projetoOrderByRelationAggregateInput
  }

  export type usuarioWhereUniqueInput = Prisma.AtLeast<{
    idusuario?: number
    cpf?: string
    email?: string
    AND?: usuarioWhereInput | usuarioWhereInput[]
    OR?: usuarioWhereInput[]
    NOT?: usuarioWhereInput | usuarioWhereInput[]
    nome?: StringFilter<"usuario"> | string
    hash_senha?: StringFilter<"usuario"> | string
    papel?: StringFilter<"usuario"> | string
    usuario_tipo?: IntFilter<"usuario"> | number
    projetos?: Usuario_projetoListRelationFilter
    tarefas?: TarefaListRelationFilter
    comentarios?: ComentarioListRelationFilter
    responsaveis?: Responsavel_tarefaListRelationFilter
    projetos_gestor?: ProjetoListRelationFilter
  }, "idusuario" | "cpf" | "email">

  export type usuarioOrderByWithAggregationInput = {
    idusuario?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    hash_senha?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    usuario_tipo?: SortOrder
    _count?: usuarioCountOrderByAggregateInput
    _avg?: usuarioAvgOrderByAggregateInput
    _max?: usuarioMaxOrderByAggregateInput
    _min?: usuarioMinOrderByAggregateInput
    _sum?: usuarioSumOrderByAggregateInput
  }

  export type usuarioScalarWhereWithAggregatesInput = {
    AND?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    OR?: usuarioScalarWhereWithAggregatesInput[]
    NOT?: usuarioScalarWhereWithAggregatesInput | usuarioScalarWhereWithAggregatesInput[]
    idusuario?: IntWithAggregatesFilter<"usuario"> | number
    cpf?: StringWithAggregatesFilter<"usuario"> | string
    nome?: StringWithAggregatesFilter<"usuario"> | string
    hash_senha?: StringWithAggregatesFilter<"usuario"> | string
    email?: StringWithAggregatesFilter<"usuario"> | string
    papel?: StringWithAggregatesFilter<"usuario"> | string
    usuario_tipo?: IntWithAggregatesFilter<"usuario"> | number
  }

  export type projetoWhereInput = {
    AND?: projetoWhereInput | projetoWhereInput[]
    OR?: projetoWhereInput[]
    NOT?: projetoWhereInput | projetoWhereInput[]
    idprojeto?: IntFilter<"projeto"> | number
    nome?: StringFilter<"projeto"> | string
    valor?: DecimalFilter<"projeto"> | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFilter<"projeto"> | Date | string
    prazo?: DateTimeFilter<"projeto"> | Date | string
    status?: StringFilter<"projeto"> | string
    descricao?: StringFilter<"projeto"> | string
    foto?: BytesFilter<"projeto"> | Buffer
    id_gestor?: IntFilter<"projeto"> | number
    usuarios?: Usuario_projetoListRelationFilter
    gestor?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    tarefa?: TarefaListRelationFilter
  }

  export type projetoOrderByWithRelationInput = {
    idprojeto?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    foto?: SortOrder
    id_gestor?: SortOrder
    usuarios?: usuario_projetoOrderByRelationAggregateInput
    gestor?: usuarioOrderByWithRelationInput
    tarefa?: tarefaOrderByRelationAggregateInput
  }

  export type projetoWhereUniqueInput = Prisma.AtLeast<{
    idprojeto?: number
    AND?: projetoWhereInput | projetoWhereInput[]
    OR?: projetoWhereInput[]
    NOT?: projetoWhereInput | projetoWhereInput[]
    nome?: StringFilter<"projeto"> | string
    valor?: DecimalFilter<"projeto"> | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFilter<"projeto"> | Date | string
    prazo?: DateTimeFilter<"projeto"> | Date | string
    status?: StringFilter<"projeto"> | string
    descricao?: StringFilter<"projeto"> | string
    foto?: BytesFilter<"projeto"> | Buffer
    id_gestor?: IntFilter<"projeto"> | number
    usuarios?: Usuario_projetoListRelationFilter
    gestor?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    tarefa?: TarefaListRelationFilter
  }, "idprojeto">

  export type projetoOrderByWithAggregationInput = {
    idprojeto?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    foto?: SortOrder
    id_gestor?: SortOrder
    _count?: projetoCountOrderByAggregateInput
    _avg?: projetoAvgOrderByAggregateInput
    _max?: projetoMaxOrderByAggregateInput
    _min?: projetoMinOrderByAggregateInput
    _sum?: projetoSumOrderByAggregateInput
  }

  export type projetoScalarWhereWithAggregatesInput = {
    AND?: projetoScalarWhereWithAggregatesInput | projetoScalarWhereWithAggregatesInput[]
    OR?: projetoScalarWhereWithAggregatesInput[]
    NOT?: projetoScalarWhereWithAggregatesInput | projetoScalarWhereWithAggregatesInput[]
    idprojeto?: IntWithAggregatesFilter<"projeto"> | number
    nome?: StringWithAggregatesFilter<"projeto"> | string
    valor?: DecimalWithAggregatesFilter<"projeto"> | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeWithAggregatesFilter<"projeto"> | Date | string
    prazo?: DateTimeWithAggregatesFilter<"projeto"> | Date | string
    status?: StringWithAggregatesFilter<"projeto"> | string
    descricao?: StringWithAggregatesFilter<"projeto"> | string
    foto?: BytesWithAggregatesFilter<"projeto"> | Buffer
    id_gestor?: IntWithAggregatesFilter<"projeto"> | number
  }

  export type tarefaWhereInput = {
    AND?: tarefaWhereInput | tarefaWhereInput[]
    OR?: tarefaWhereInput[]
    NOT?: tarefaWhereInput | tarefaWhereInput[]
    idtarefa?: IntFilter<"tarefa"> | number
    nome?: StringNullableFilter<"tarefa"> | string | null
    data_inicio?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    prazo?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    status?: StringNullableFilter<"tarefa"> | string | null
    descricao?: StringNullableFilter<"tarefa"> | string | null
    id_projeto?: IntNullableFilter<"tarefa"> | number | null
    id_gestor?: IntNullableFilter<"tarefa"> | number | null
    projeto?: XOR<ProjetoNullableRelationFilter, projetoWhereInput> | null
    gestor?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    comentario?: ComentarioListRelationFilter
    responsavel_tarefa?: Responsavel_tarefaListRelationFilter
  }

  export type tarefaOrderByWithRelationInput = {
    idtarefa?: SortOrder
    nome?: SortOrderInput | SortOrder
    data_inicio?: SortOrderInput | SortOrder
    prazo?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    id_projeto?: SortOrderInput | SortOrder
    id_gestor?: SortOrderInput | SortOrder
    projeto?: projetoOrderByWithRelationInput
    gestor?: usuarioOrderByWithRelationInput
    comentario?: comentarioOrderByRelationAggregateInput
    responsavel_tarefa?: responsavel_tarefaOrderByRelationAggregateInput
  }

  export type tarefaWhereUniqueInput = Prisma.AtLeast<{
    idtarefa?: number
    AND?: tarefaWhereInput | tarefaWhereInput[]
    OR?: tarefaWhereInput[]
    NOT?: tarefaWhereInput | tarefaWhereInput[]
    nome?: StringNullableFilter<"tarefa"> | string | null
    data_inicio?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    prazo?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    status?: StringNullableFilter<"tarefa"> | string | null
    descricao?: StringNullableFilter<"tarefa"> | string | null
    id_projeto?: IntNullableFilter<"tarefa"> | number | null
    id_gestor?: IntNullableFilter<"tarefa"> | number | null
    projeto?: XOR<ProjetoNullableRelationFilter, projetoWhereInput> | null
    gestor?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
    comentario?: ComentarioListRelationFilter
    responsavel_tarefa?: Responsavel_tarefaListRelationFilter
  }, "idtarefa">

  export type tarefaOrderByWithAggregationInput = {
    idtarefa?: SortOrder
    nome?: SortOrderInput | SortOrder
    data_inicio?: SortOrderInput | SortOrder
    prazo?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    id_projeto?: SortOrderInput | SortOrder
    id_gestor?: SortOrderInput | SortOrder
    _count?: tarefaCountOrderByAggregateInput
    _avg?: tarefaAvgOrderByAggregateInput
    _max?: tarefaMaxOrderByAggregateInput
    _min?: tarefaMinOrderByAggregateInput
    _sum?: tarefaSumOrderByAggregateInput
  }

  export type tarefaScalarWhereWithAggregatesInput = {
    AND?: tarefaScalarWhereWithAggregatesInput | tarefaScalarWhereWithAggregatesInput[]
    OR?: tarefaScalarWhereWithAggregatesInput[]
    NOT?: tarefaScalarWhereWithAggregatesInput | tarefaScalarWhereWithAggregatesInput[]
    idtarefa?: IntWithAggregatesFilter<"tarefa"> | number
    nome?: StringNullableWithAggregatesFilter<"tarefa"> | string | null
    data_inicio?: DateTimeNullableWithAggregatesFilter<"tarefa"> | Date | string | null
    prazo?: DateTimeNullableWithAggregatesFilter<"tarefa"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"tarefa"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"tarefa"> | string | null
    id_projeto?: IntNullableWithAggregatesFilter<"tarefa"> | number | null
    id_gestor?: IntNullableWithAggregatesFilter<"tarefa"> | number | null
  }

  export type usuario_projetoWhereInput = {
    AND?: usuario_projetoWhereInput | usuario_projetoWhereInput[]
    OR?: usuario_projetoWhereInput[]
    NOT?: usuario_projetoWhereInput | usuario_projetoWhereInput[]
    idusuario?: IntFilter<"usuario_projeto"> | number
    idprojeto?: IntFilter<"usuario_projeto"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }

  export type usuario_projetoOrderByWithRelationInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    projeto?: projetoOrderByWithRelationInput
  }

  export type usuario_projetoWhereUniqueInput = Prisma.AtLeast<{
    idusuario_idprojeto?: usuario_projetoIdusuarioIdprojetoCompoundUniqueInput
    AND?: usuario_projetoWhereInput | usuario_projetoWhereInput[]
    OR?: usuario_projetoWhereInput[]
    NOT?: usuario_projetoWhereInput | usuario_projetoWhereInput[]
    idusuario?: IntFilter<"usuario_projeto"> | number
    idprojeto?: IntFilter<"usuario_projeto"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    projeto?: XOR<ProjetoRelationFilter, projetoWhereInput>
  }, "idusuario_idprojeto">

  export type usuario_projetoOrderByWithAggregationInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
    _count?: usuario_projetoCountOrderByAggregateInput
    _avg?: usuario_projetoAvgOrderByAggregateInput
    _max?: usuario_projetoMaxOrderByAggregateInput
    _min?: usuario_projetoMinOrderByAggregateInput
    _sum?: usuario_projetoSumOrderByAggregateInput
  }

  export type usuario_projetoScalarWhereWithAggregatesInput = {
    AND?: usuario_projetoScalarWhereWithAggregatesInput | usuario_projetoScalarWhereWithAggregatesInput[]
    OR?: usuario_projetoScalarWhereWithAggregatesInput[]
    NOT?: usuario_projetoScalarWhereWithAggregatesInput | usuario_projetoScalarWhereWithAggregatesInput[]
    idusuario?: IntWithAggregatesFilter<"usuario_projeto"> | number
    idprojeto?: IntWithAggregatesFilter<"usuario_projeto"> | number
  }

  export type responsavel_tarefaWhereInput = {
    AND?: responsavel_tarefaWhereInput | responsavel_tarefaWhereInput[]
    OR?: responsavel_tarefaWhereInput[]
    NOT?: responsavel_tarefaWhereInput | responsavel_tarefaWhereInput[]
    id_usuario?: IntFilter<"responsavel_tarefa"> | number
    id_tarefa?: IntFilter<"responsavel_tarefa"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
  }

  export type responsavel_tarefaOrderByWithRelationInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
    usuario?: usuarioOrderByWithRelationInput
    tarefa?: tarefaOrderByWithRelationInput
  }

  export type responsavel_tarefaWhereUniqueInput = Prisma.AtLeast<{
    id_tarefa_id_usuario?: responsavel_tarefaId_tarefaId_usuarioCompoundUniqueInput
    AND?: responsavel_tarefaWhereInput | responsavel_tarefaWhereInput[]
    OR?: responsavel_tarefaWhereInput[]
    NOT?: responsavel_tarefaWhereInput | responsavel_tarefaWhereInput[]
    id_usuario?: IntFilter<"responsavel_tarefa"> | number
    id_tarefa?: IntFilter<"responsavel_tarefa"> | number
    usuario?: XOR<UsuarioRelationFilter, usuarioWhereInput>
    tarefa?: XOR<TarefaRelationFilter, tarefaWhereInput>
  }, "id_tarefa_id_usuario">

  export type responsavel_tarefaOrderByWithAggregationInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
    _count?: responsavel_tarefaCountOrderByAggregateInput
    _avg?: responsavel_tarefaAvgOrderByAggregateInput
    _max?: responsavel_tarefaMaxOrderByAggregateInput
    _min?: responsavel_tarefaMinOrderByAggregateInput
    _sum?: responsavel_tarefaSumOrderByAggregateInput
  }

  export type responsavel_tarefaScalarWhereWithAggregatesInput = {
    AND?: responsavel_tarefaScalarWhereWithAggregatesInput | responsavel_tarefaScalarWhereWithAggregatesInput[]
    OR?: responsavel_tarefaScalarWhereWithAggregatesInput[]
    NOT?: responsavel_tarefaScalarWhereWithAggregatesInput | responsavel_tarefaScalarWhereWithAggregatesInput[]
    id_usuario?: IntWithAggregatesFilter<"responsavel_tarefa"> | number
    id_tarefa?: IntWithAggregatesFilter<"responsavel_tarefa"> | number
  }

  export type comentarioWhereInput = {
    AND?: comentarioWhereInput | comentarioWhereInput[]
    OR?: comentarioWhereInput[]
    NOT?: comentarioWhereInput | comentarioWhereInput[]
    idcomentario?: IntFilter<"comentario"> | number
    texto?: StringNullableFilter<"comentario"> | string | null
    id_tarefa?: IntNullableFilter<"comentario"> | number | null
    id_usuario?: IntNullableFilter<"comentario"> | number | null
    tarefa?: XOR<TarefaNullableRelationFilter, tarefaWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }

  export type comentarioOrderByWithRelationInput = {
    idcomentario?: SortOrder
    texto?: SortOrderInput | SortOrder
    id_tarefa?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    tarefa?: tarefaOrderByWithRelationInput
    usuario?: usuarioOrderByWithRelationInput
  }

  export type comentarioWhereUniqueInput = Prisma.AtLeast<{
    idcomentario?: number
    AND?: comentarioWhereInput | comentarioWhereInput[]
    OR?: comentarioWhereInput[]
    NOT?: comentarioWhereInput | comentarioWhereInput[]
    texto?: StringNullableFilter<"comentario"> | string | null
    id_tarefa?: IntNullableFilter<"comentario"> | number | null
    id_usuario?: IntNullableFilter<"comentario"> | number | null
    tarefa?: XOR<TarefaNullableRelationFilter, tarefaWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, usuarioWhereInput> | null
  }, "idcomentario">

  export type comentarioOrderByWithAggregationInput = {
    idcomentario?: SortOrder
    texto?: SortOrderInput | SortOrder
    id_tarefa?: SortOrderInput | SortOrder
    id_usuario?: SortOrderInput | SortOrder
    _count?: comentarioCountOrderByAggregateInput
    _avg?: comentarioAvgOrderByAggregateInput
    _max?: comentarioMaxOrderByAggregateInput
    _min?: comentarioMinOrderByAggregateInput
    _sum?: comentarioSumOrderByAggregateInput
  }

  export type comentarioScalarWhereWithAggregatesInput = {
    AND?: comentarioScalarWhereWithAggregatesInput | comentarioScalarWhereWithAggregatesInput[]
    OR?: comentarioScalarWhereWithAggregatesInput[]
    NOT?: comentarioScalarWhereWithAggregatesInput | comentarioScalarWhereWithAggregatesInput[]
    idcomentario?: IntWithAggregatesFilter<"comentario"> | number
    texto?: StringNullableWithAggregatesFilter<"comentario"> | string | null
    id_tarefa?: IntNullableWithAggregatesFilter<"comentario"> | number | null
    id_usuario?: IntNullableWithAggregatesFilter<"comentario"> | number | null
  }

  export type todoWhereInput = {
    AND?: todoWhereInput | todoWhereInput[]
    OR?: todoWhereInput[]
    NOT?: todoWhereInput | todoWhereInput[]
    IDTODO?: IntFilter<"todo"> | number
    TITLE?: StringFilter<"todo"> | string
    DESCRIPTION?: StringFilter<"todo"> | string
  }

  export type todoOrderByWithRelationInput = {
    IDTODO?: SortOrder
    TITLE?: SortOrder
    DESCRIPTION?: SortOrder
  }

  export type todoWhereUniqueInput = Prisma.AtLeast<{
    IDTODO?: number
    AND?: todoWhereInput | todoWhereInput[]
    OR?: todoWhereInput[]
    NOT?: todoWhereInput | todoWhereInput[]
    TITLE?: StringFilter<"todo"> | string
    DESCRIPTION?: StringFilter<"todo"> | string
  }, "IDTODO">

  export type todoOrderByWithAggregationInput = {
    IDTODO?: SortOrder
    TITLE?: SortOrder
    DESCRIPTION?: SortOrder
    _count?: todoCountOrderByAggregateInput
    _avg?: todoAvgOrderByAggregateInput
    _max?: todoMaxOrderByAggregateInput
    _min?: todoMinOrderByAggregateInput
    _sum?: todoSumOrderByAggregateInput
  }

  export type todoScalarWhereWithAggregatesInput = {
    AND?: todoScalarWhereWithAggregatesInput | todoScalarWhereWithAggregatesInput[]
    OR?: todoScalarWhereWithAggregatesInput[]
    NOT?: todoScalarWhereWithAggregatesInput | todoScalarWhereWithAggregatesInput[]
    IDTODO?: IntWithAggregatesFilter<"todo"> | number
    TITLE?: StringWithAggregatesFilter<"todo"> | string
    DESCRIPTION?: StringWithAggregatesFilter<"todo"> | string
  }

  export type usuarioCreateInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaCreateNestedManyWithoutGestorInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoCreateNestedManyWithoutGestorInput
  }

  export type usuarioUncheckedCreateInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaUncheckedCreateNestedManyWithoutGestorInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoUncheckedCreateNestedManyWithoutGestorInput
  }

  export type usuarioUpdateInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUpdateManyWithoutGestorNestedInput
  }

  export type usuarioUncheckedUpdateInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUncheckedUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUncheckedUpdateManyWithoutGestorNestedInput
  }

  export type usuarioCreateManyInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
  }

  export type usuarioUpdateManyMutationInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
  }

  export type usuarioUncheckedUpdateManyInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
  }

  export type projetoCreateInput = {
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    usuarios?: usuario_projetoCreateNestedManyWithoutProjetoInput
    gestor?: usuarioCreateNestedOneWithoutProjetos_gestorInput
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    id_gestor: number
    usuarios?: usuario_projetoUncheckedCreateNestedManyWithoutProjetoInput
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    usuarios?: usuario_projetoUpdateManyWithoutProjetoNestedInput
    gestor?: usuarioUpdateOneWithoutProjetos_gestorNestedInput
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    id_gestor?: IntFieldUpdateOperationsInput | number
    usuarios?: usuario_projetoUncheckedUpdateManyWithoutProjetoNestedInput
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type projetoCreateManyInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    id_gestor: number
  }

  export type projetoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type projetoUncheckedUpdateManyInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    id_gestor?: IntFieldUpdateOperationsInput | number
  }

  export type tarefaCreateInput = {
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    projeto?: projetoCreateNestedOneWithoutTarefaInput
    gestor?: usuarioCreateNestedOneWithoutTarefasInput
    comentario?: comentarioCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
    id_gestor?: number | null
    comentario?: comentarioUncheckedCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUpdateInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: projetoUpdateOneWithoutTarefaNestedInput
    gestor?: usuarioUpdateOneWithoutTarefasNestedInput
    comentario?: comentarioUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: comentarioUncheckedUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaCreateManyInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
    id_gestor?: number | null
  }

  export type tarefaUpdateManyMutationInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tarefaUncheckedUpdateManyInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usuario_projetoCreateInput = {
    usuario: usuarioCreateNestedOneWithoutProjetosInput
    projeto: projetoCreateNestedOneWithoutUsuariosInput
  }

  export type usuario_projetoUncheckedCreateInput = {
    idusuario: number
    idprojeto: number
  }

  export type usuario_projetoUpdateInput = {
    usuario?: usuarioUpdateOneRequiredWithoutProjetosNestedInput
    projeto?: projetoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type usuario_projetoUncheckedUpdateInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    idprojeto?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_projetoCreateManyInput = {
    idusuario: number
    idprojeto: number
  }

  export type usuario_projetoUpdateManyMutationInput = {

  }

  export type usuario_projetoUncheckedUpdateManyInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    idprojeto?: IntFieldUpdateOperationsInput | number
  }

  export type responsavel_tarefaCreateInput = {
    usuario: usuarioCreateNestedOneWithoutResponsaveisInput
    tarefa: tarefaCreateNestedOneWithoutResponsavel_tarefaInput
  }

  export type responsavel_tarefaUncheckedCreateInput = {
    id_usuario: number
    id_tarefa: number
  }

  export type responsavel_tarefaUpdateInput = {
    usuario?: usuarioUpdateOneRequiredWithoutResponsaveisNestedInput
    tarefa?: tarefaUpdateOneRequiredWithoutResponsavel_tarefaNestedInput
  }

  export type responsavel_tarefaUncheckedUpdateInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_tarefa?: IntFieldUpdateOperationsInput | number
  }

  export type responsavel_tarefaCreateManyInput = {
    id_usuario: number
    id_tarefa: number
  }

  export type responsavel_tarefaUpdateManyMutationInput = {

  }

  export type responsavel_tarefaUncheckedUpdateManyInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
    id_tarefa?: IntFieldUpdateOperationsInput | number
  }

  export type comentarioCreateInput = {
    texto?: string | null
    tarefa?: tarefaCreateNestedOneWithoutComentarioInput
    usuario?: usuarioCreateNestedOneWithoutComentariosInput
  }

  export type comentarioUncheckedCreateInput = {
    idcomentario?: number
    texto?: string | null
    id_tarefa?: number | null
    id_usuario?: number | null
  }

  export type comentarioUpdateInput = {
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    tarefa?: tarefaUpdateOneWithoutComentarioNestedInput
    usuario?: usuarioUpdateOneWithoutComentariosNestedInput
  }

  export type comentarioUncheckedUpdateInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_tarefa?: NullableIntFieldUpdateOperationsInput | number | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comentarioCreateManyInput = {
    idcomentario?: number
    texto?: string | null
    id_tarefa?: number | null
    id_usuario?: number | null
  }

  export type comentarioUpdateManyMutationInput = {
    texto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type comentarioUncheckedUpdateManyInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_tarefa?: NullableIntFieldUpdateOperationsInput | number | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type todoCreateInput = {
    TITLE: string
    DESCRIPTION: string
  }

  export type todoUncheckedCreateInput = {
    IDTODO?: number
    TITLE: string
    DESCRIPTION: string
  }

  export type todoUpdateInput = {
    TITLE?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: StringFieldUpdateOperationsInput | string
  }

  export type todoUncheckedUpdateInput = {
    IDTODO?: IntFieldUpdateOperationsInput | number
    TITLE?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: StringFieldUpdateOperationsInput | string
  }

  export type todoCreateManyInput = {
    IDTODO?: number
    TITLE: string
    DESCRIPTION: string
  }

  export type todoUpdateManyMutationInput = {
    TITLE?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: StringFieldUpdateOperationsInput | string
  }

  export type todoUncheckedUpdateManyInput = {
    IDTODO?: IntFieldUpdateOperationsInput | number
    TITLE?: StringFieldUpdateOperationsInput | string
    DESCRIPTION?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Usuario_projetoListRelationFilter = {
    every?: usuario_projetoWhereInput
    some?: usuario_projetoWhereInput
    none?: usuario_projetoWhereInput
  }

  export type TarefaListRelationFilter = {
    every?: tarefaWhereInput
    some?: tarefaWhereInput
    none?: tarefaWhereInput
  }

  export type ComentarioListRelationFilter = {
    every?: comentarioWhereInput
    some?: comentarioWhereInput
    none?: comentarioWhereInput
  }

  export type Responsavel_tarefaListRelationFilter = {
    every?: responsavel_tarefaWhereInput
    some?: responsavel_tarefaWhereInput
    none?: responsavel_tarefaWhereInput
  }

  export type ProjetoListRelationFilter = {
    every?: projetoWhereInput
    some?: projetoWhereInput
    none?: projetoWhereInput
  }

  export type usuario_projetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tarefaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comentarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type responsavel_tarefaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projetoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usuarioCountOrderByAggregateInput = {
    idusuario?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    hash_senha?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    usuario_tipo?: SortOrder
  }

  export type usuarioAvgOrderByAggregateInput = {
    idusuario?: SortOrder
    usuario_tipo?: SortOrder
  }

  export type usuarioMaxOrderByAggregateInput = {
    idusuario?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    hash_senha?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    usuario_tipo?: SortOrder
  }

  export type usuarioMinOrderByAggregateInput = {
    idusuario?: SortOrder
    cpf?: SortOrder
    nome?: SortOrder
    hash_senha?: SortOrder
    email?: SortOrder
    papel?: SortOrder
    usuario_tipo?: SortOrder
  }

  export type usuarioSumOrderByAggregateInput = {
    idusuario?: SortOrder
    usuario_tipo?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type UsuarioNullableRelationFilter = {
    is?: usuarioWhereInput | null
    isNot?: usuarioWhereInput | null
  }

  export type projetoCountOrderByAggregateInput = {
    idprojeto?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    foto?: SortOrder
    id_gestor?: SortOrder
  }

  export type projetoAvgOrderByAggregateInput = {
    idprojeto?: SortOrder
    valor?: SortOrder
    id_gestor?: SortOrder
  }

  export type projetoMaxOrderByAggregateInput = {
    idprojeto?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    foto?: SortOrder
    id_gestor?: SortOrder
  }

  export type projetoMinOrderByAggregateInput = {
    idprojeto?: SortOrder
    nome?: SortOrder
    valor?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    foto?: SortOrder
    id_gestor?: SortOrder
  }

  export type projetoSumOrderByAggregateInput = {
    idprojeto?: SortOrder
    valor?: SortOrder
    id_gestor?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ProjetoNullableRelationFilter = {
    is?: projetoWhereInput | null
    isNot?: projetoWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type tarefaCountOrderByAggregateInput = {
    idtarefa?: SortOrder
    nome?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    id_projeto?: SortOrder
    id_gestor?: SortOrder
  }

  export type tarefaAvgOrderByAggregateInput = {
    idtarefa?: SortOrder
    id_projeto?: SortOrder
    id_gestor?: SortOrder
  }

  export type tarefaMaxOrderByAggregateInput = {
    idtarefa?: SortOrder
    nome?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    id_projeto?: SortOrder
    id_gestor?: SortOrder
  }

  export type tarefaMinOrderByAggregateInput = {
    idtarefa?: SortOrder
    nome?: SortOrder
    data_inicio?: SortOrder
    prazo?: SortOrder
    status?: SortOrder
    descricao?: SortOrder
    id_projeto?: SortOrder
    id_gestor?: SortOrder
  }

  export type tarefaSumOrderByAggregateInput = {
    idtarefa?: SortOrder
    id_projeto?: SortOrder
    id_gestor?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type UsuarioRelationFilter = {
    is?: usuarioWhereInput
    isNot?: usuarioWhereInput
  }

  export type ProjetoRelationFilter = {
    is?: projetoWhereInput
    isNot?: projetoWhereInput
  }

  export type usuario_projetoIdusuarioIdprojetoCompoundUniqueInput = {
    idusuario: number
    idprojeto: number
  }

  export type usuario_projetoCountOrderByAggregateInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
  }

  export type usuario_projetoAvgOrderByAggregateInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
  }

  export type usuario_projetoMaxOrderByAggregateInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
  }

  export type usuario_projetoMinOrderByAggregateInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
  }

  export type usuario_projetoSumOrderByAggregateInput = {
    idusuario?: SortOrder
    idprojeto?: SortOrder
  }

  export type TarefaRelationFilter = {
    is?: tarefaWhereInput
    isNot?: tarefaWhereInput
  }

  export type responsavel_tarefaId_tarefaId_usuarioCompoundUniqueInput = {
    id_tarefa: number
    id_usuario: number
  }

  export type responsavel_tarefaCountOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
  }

  export type responsavel_tarefaAvgOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
  }

  export type responsavel_tarefaMaxOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
  }

  export type responsavel_tarefaMinOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
  }

  export type responsavel_tarefaSumOrderByAggregateInput = {
    id_usuario?: SortOrder
    id_tarefa?: SortOrder
  }

  export type TarefaNullableRelationFilter = {
    is?: tarefaWhereInput | null
    isNot?: tarefaWhereInput | null
  }

  export type comentarioCountOrderByAggregateInput = {
    idcomentario?: SortOrder
    texto?: SortOrder
    id_tarefa?: SortOrder
    id_usuario?: SortOrder
  }

  export type comentarioAvgOrderByAggregateInput = {
    idcomentario?: SortOrder
    id_tarefa?: SortOrder
    id_usuario?: SortOrder
  }

  export type comentarioMaxOrderByAggregateInput = {
    idcomentario?: SortOrder
    texto?: SortOrder
    id_tarefa?: SortOrder
    id_usuario?: SortOrder
  }

  export type comentarioMinOrderByAggregateInput = {
    idcomentario?: SortOrder
    texto?: SortOrder
    id_tarefa?: SortOrder
    id_usuario?: SortOrder
  }

  export type comentarioSumOrderByAggregateInput = {
    idcomentario?: SortOrder
    id_tarefa?: SortOrder
    id_usuario?: SortOrder
  }

  export type todoCountOrderByAggregateInput = {
    IDTODO?: SortOrder
    TITLE?: SortOrder
    DESCRIPTION?: SortOrder
  }

  export type todoAvgOrderByAggregateInput = {
    IDTODO?: SortOrder
  }

  export type todoMaxOrderByAggregateInput = {
    IDTODO?: SortOrder
    TITLE?: SortOrder
    DESCRIPTION?: SortOrder
  }

  export type todoMinOrderByAggregateInput = {
    IDTODO?: SortOrder
    TITLE?: SortOrder
    DESCRIPTION?: SortOrder
  }

  export type todoSumOrderByAggregateInput = {
    IDTODO?: SortOrder
  }

  export type usuario_projetoCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput> | usuario_projetoCreateWithoutUsuarioInput[] | usuario_projetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutUsuarioInput | usuario_projetoCreateOrConnectWithoutUsuarioInput[]
    createMany?: usuario_projetoCreateManyUsuarioInputEnvelope
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
  }

  export type tarefaCreateNestedManyWithoutGestorInput = {
    create?: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput> | tarefaCreateWithoutGestorInput[] | tarefaUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutGestorInput | tarefaCreateOrConnectWithoutGestorInput[]
    createMany?: tarefaCreateManyGestorInputEnvelope
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
  }

  export type comentarioCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type responsavel_tarefaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput> | responsavel_tarefaCreateWithoutUsuarioInput[] | responsavel_tarefaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutUsuarioInput | responsavel_tarefaCreateOrConnectWithoutUsuarioInput[]
    createMany?: responsavel_tarefaCreateManyUsuarioInputEnvelope
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
  }

  export type projetoCreateNestedManyWithoutGestorInput = {
    create?: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput> | projetoCreateWithoutGestorInput[] | projetoUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: projetoCreateOrConnectWithoutGestorInput | projetoCreateOrConnectWithoutGestorInput[]
    createMany?: projetoCreateManyGestorInputEnvelope
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
  }

  export type usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput> | usuario_projetoCreateWithoutUsuarioInput[] | usuario_projetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutUsuarioInput | usuario_projetoCreateOrConnectWithoutUsuarioInput[]
    createMany?: usuario_projetoCreateManyUsuarioInputEnvelope
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
  }

  export type tarefaUncheckedCreateNestedManyWithoutGestorInput = {
    create?: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput> | tarefaCreateWithoutGestorInput[] | tarefaUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutGestorInput | tarefaCreateOrConnectWithoutGestorInput[]
    createMany?: tarefaCreateManyGestorInputEnvelope
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
  }

  export type comentarioUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput> | responsavel_tarefaCreateWithoutUsuarioInput[] | responsavel_tarefaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutUsuarioInput | responsavel_tarefaCreateOrConnectWithoutUsuarioInput[]
    createMany?: responsavel_tarefaCreateManyUsuarioInputEnvelope
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
  }

  export type projetoUncheckedCreateNestedManyWithoutGestorInput = {
    create?: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput> | projetoCreateWithoutGestorInput[] | projetoUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: projetoCreateOrConnectWithoutGestorInput | projetoCreateOrConnectWithoutGestorInput[]
    createMany?: projetoCreateManyGestorInputEnvelope
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usuario_projetoUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput> | usuario_projetoCreateWithoutUsuarioInput[] | usuario_projetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutUsuarioInput | usuario_projetoCreateOrConnectWithoutUsuarioInput[]
    upsert?: usuario_projetoUpsertWithWhereUniqueWithoutUsuarioInput | usuario_projetoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: usuario_projetoCreateManyUsuarioInputEnvelope
    set?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    disconnect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    delete?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    update?: usuario_projetoUpdateWithWhereUniqueWithoutUsuarioInput | usuario_projetoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: usuario_projetoUpdateManyWithWhereWithoutUsuarioInput | usuario_projetoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
  }

  export type tarefaUpdateManyWithoutGestorNestedInput = {
    create?: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput> | tarefaCreateWithoutGestorInput[] | tarefaUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutGestorInput | tarefaCreateOrConnectWithoutGestorInput[]
    upsert?: tarefaUpsertWithWhereUniqueWithoutGestorInput | tarefaUpsertWithWhereUniqueWithoutGestorInput[]
    createMany?: tarefaCreateManyGestorInputEnvelope
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    update?: tarefaUpdateWithWhereUniqueWithoutGestorInput | tarefaUpdateWithWhereUniqueWithoutGestorInput[]
    updateMany?: tarefaUpdateManyWithWhereWithoutGestorInput | tarefaUpdateManyWithWhereWithoutGestorInput[]
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
  }

  export type comentarioUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutUsuarioInput | comentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutUsuarioInput | comentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutUsuarioInput | comentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type responsavel_tarefaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput> | responsavel_tarefaCreateWithoutUsuarioInput[] | responsavel_tarefaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutUsuarioInput | responsavel_tarefaCreateOrConnectWithoutUsuarioInput[]
    upsert?: responsavel_tarefaUpsertWithWhereUniqueWithoutUsuarioInput | responsavel_tarefaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: responsavel_tarefaCreateManyUsuarioInputEnvelope
    set?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    disconnect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    delete?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    update?: responsavel_tarefaUpdateWithWhereUniqueWithoutUsuarioInput | responsavel_tarefaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: responsavel_tarefaUpdateManyWithWhereWithoutUsuarioInput | responsavel_tarefaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
  }

  export type projetoUpdateManyWithoutGestorNestedInput = {
    create?: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput> | projetoCreateWithoutGestorInput[] | projetoUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: projetoCreateOrConnectWithoutGestorInput | projetoCreateOrConnectWithoutGestorInput[]
    upsert?: projetoUpsertWithWhereUniqueWithoutGestorInput | projetoUpsertWithWhereUniqueWithoutGestorInput[]
    createMany?: projetoCreateManyGestorInputEnvelope
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    update?: projetoUpdateWithWhereUniqueWithoutGestorInput | projetoUpdateWithWhereUniqueWithoutGestorInput[]
    updateMany?: projetoUpdateManyWithWhereWithoutGestorInput | projetoUpdateManyWithWhereWithoutGestorInput[]
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[]
  }

  export type usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput> | usuario_projetoCreateWithoutUsuarioInput[] | usuario_projetoUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutUsuarioInput | usuario_projetoCreateOrConnectWithoutUsuarioInput[]
    upsert?: usuario_projetoUpsertWithWhereUniqueWithoutUsuarioInput | usuario_projetoUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: usuario_projetoCreateManyUsuarioInputEnvelope
    set?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    disconnect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    delete?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    update?: usuario_projetoUpdateWithWhereUniqueWithoutUsuarioInput | usuario_projetoUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: usuario_projetoUpdateManyWithWhereWithoutUsuarioInput | usuario_projetoUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
  }

  export type tarefaUncheckedUpdateManyWithoutGestorNestedInput = {
    create?: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput> | tarefaCreateWithoutGestorInput[] | tarefaUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutGestorInput | tarefaCreateOrConnectWithoutGestorInput[]
    upsert?: tarefaUpsertWithWhereUniqueWithoutGestorInput | tarefaUpsertWithWhereUniqueWithoutGestorInput[]
    createMany?: tarefaCreateManyGestorInputEnvelope
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    update?: tarefaUpdateWithWhereUniqueWithoutGestorInput | tarefaUpdateWithWhereUniqueWithoutGestorInput[]
    updateMany?: tarefaUpdateManyWithWhereWithoutGestorInput | tarefaUpdateManyWithWhereWithoutGestorInput[]
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
  }

  export type comentarioUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput> | comentarioCreateWithoutUsuarioInput[] | comentarioUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutUsuarioInput | comentarioCreateOrConnectWithoutUsuarioInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutUsuarioInput | comentarioUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: comentarioCreateManyUsuarioInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutUsuarioInput | comentarioUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutUsuarioInput | comentarioUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput> | responsavel_tarefaCreateWithoutUsuarioInput[] | responsavel_tarefaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutUsuarioInput | responsavel_tarefaCreateOrConnectWithoutUsuarioInput[]
    upsert?: responsavel_tarefaUpsertWithWhereUniqueWithoutUsuarioInput | responsavel_tarefaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: responsavel_tarefaCreateManyUsuarioInputEnvelope
    set?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    disconnect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    delete?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    update?: responsavel_tarefaUpdateWithWhereUniqueWithoutUsuarioInput | responsavel_tarefaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: responsavel_tarefaUpdateManyWithWhereWithoutUsuarioInput | responsavel_tarefaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
  }

  export type projetoUncheckedUpdateManyWithoutGestorNestedInput = {
    create?: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput> | projetoCreateWithoutGestorInput[] | projetoUncheckedCreateWithoutGestorInput[]
    connectOrCreate?: projetoCreateOrConnectWithoutGestorInput | projetoCreateOrConnectWithoutGestorInput[]
    upsert?: projetoUpsertWithWhereUniqueWithoutGestorInput | projetoUpsertWithWhereUniqueWithoutGestorInput[]
    createMany?: projetoCreateManyGestorInputEnvelope
    set?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    disconnect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    delete?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    connect?: projetoWhereUniqueInput | projetoWhereUniqueInput[]
    update?: projetoUpdateWithWhereUniqueWithoutGestorInput | projetoUpdateWithWhereUniqueWithoutGestorInput[]
    updateMany?: projetoUpdateManyWithWhereWithoutGestorInput | projetoUpdateManyWithWhereWithoutGestorInput[]
    deleteMany?: projetoScalarWhereInput | projetoScalarWhereInput[]
  }

  export type usuario_projetoCreateNestedManyWithoutProjetoInput = {
    create?: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput> | usuario_projetoCreateWithoutProjetoInput[] | usuario_projetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutProjetoInput | usuario_projetoCreateOrConnectWithoutProjetoInput[]
    createMany?: usuario_projetoCreateManyProjetoInputEnvelope
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
  }

  export type usuarioCreateNestedOneWithoutProjetos_gestorInput = {
    create?: XOR<usuarioCreateWithoutProjetos_gestorInput, usuarioUncheckedCreateWithoutProjetos_gestorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetos_gestorInput
    connect?: usuarioWhereUniqueInput
  }

  export type tarefaCreateNestedManyWithoutProjetoInput = {
    create?: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput> | tarefaCreateWithoutProjetoInput[] | tarefaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutProjetoInput | tarefaCreateOrConnectWithoutProjetoInput[]
    createMany?: tarefaCreateManyProjetoInputEnvelope
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
  }

  export type usuario_projetoUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput> | usuario_projetoCreateWithoutProjetoInput[] | usuario_projetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutProjetoInput | usuario_projetoCreateOrConnectWithoutProjetoInput[]
    createMany?: usuario_projetoCreateManyProjetoInputEnvelope
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
  }

  export type tarefaUncheckedCreateNestedManyWithoutProjetoInput = {
    create?: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput> | tarefaCreateWithoutProjetoInput[] | tarefaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutProjetoInput | tarefaCreateOrConnectWithoutProjetoInput[]
    createMany?: tarefaCreateManyProjetoInputEnvelope
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type usuario_projetoUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput> | usuario_projetoCreateWithoutProjetoInput[] | usuario_projetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutProjetoInput | usuario_projetoCreateOrConnectWithoutProjetoInput[]
    upsert?: usuario_projetoUpsertWithWhereUniqueWithoutProjetoInput | usuario_projetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: usuario_projetoCreateManyProjetoInputEnvelope
    set?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    disconnect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    delete?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    update?: usuario_projetoUpdateWithWhereUniqueWithoutProjetoInput | usuario_projetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: usuario_projetoUpdateManyWithWhereWithoutProjetoInput | usuario_projetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
  }

  export type usuarioUpdateOneWithoutProjetos_gestorNestedInput = {
    create?: XOR<usuarioCreateWithoutProjetos_gestorInput, usuarioUncheckedCreateWithoutProjetos_gestorInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetos_gestorInput
    upsert?: usuarioUpsertWithoutProjetos_gestorInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutProjetos_gestorInput, usuarioUpdateWithoutProjetos_gestorInput>, usuarioUncheckedUpdateWithoutProjetos_gestorInput>
  }

  export type tarefaUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput> | tarefaCreateWithoutProjetoInput[] | tarefaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutProjetoInput | tarefaCreateOrConnectWithoutProjetoInput[]
    upsert?: tarefaUpsertWithWhereUniqueWithoutProjetoInput | tarefaUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: tarefaCreateManyProjetoInputEnvelope
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    update?: tarefaUpdateWithWhereUniqueWithoutProjetoInput | tarefaUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: tarefaUpdateManyWithWhereWithoutProjetoInput | tarefaUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
  }

  export type usuario_projetoUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput> | usuario_projetoCreateWithoutProjetoInput[] | usuario_projetoUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: usuario_projetoCreateOrConnectWithoutProjetoInput | usuario_projetoCreateOrConnectWithoutProjetoInput[]
    upsert?: usuario_projetoUpsertWithWhereUniqueWithoutProjetoInput | usuario_projetoUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: usuario_projetoCreateManyProjetoInputEnvelope
    set?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    disconnect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    delete?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    connect?: usuario_projetoWhereUniqueInput | usuario_projetoWhereUniqueInput[]
    update?: usuario_projetoUpdateWithWhereUniqueWithoutProjetoInput | usuario_projetoUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: usuario_projetoUpdateManyWithWhereWithoutProjetoInput | usuario_projetoUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
  }

  export type tarefaUncheckedUpdateManyWithoutProjetoNestedInput = {
    create?: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput> | tarefaCreateWithoutProjetoInput[] | tarefaUncheckedCreateWithoutProjetoInput[]
    connectOrCreate?: tarefaCreateOrConnectWithoutProjetoInput | tarefaCreateOrConnectWithoutProjetoInput[]
    upsert?: tarefaUpsertWithWhereUniqueWithoutProjetoInput | tarefaUpsertWithWhereUniqueWithoutProjetoInput[]
    createMany?: tarefaCreateManyProjetoInputEnvelope
    set?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    disconnect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    delete?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    connect?: tarefaWhereUniqueInput | tarefaWhereUniqueInput[]
    update?: tarefaUpdateWithWhereUniqueWithoutProjetoInput | tarefaUpdateWithWhereUniqueWithoutProjetoInput[]
    updateMany?: tarefaUpdateManyWithWhereWithoutProjetoInput | tarefaUpdateManyWithWhereWithoutProjetoInput[]
    deleteMany?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
  }

  export type projetoCreateNestedOneWithoutTarefaInput = {
    create?: XOR<projetoCreateWithoutTarefaInput, projetoUncheckedCreateWithoutTarefaInput>
    connectOrCreate?: projetoCreateOrConnectWithoutTarefaInput
    connect?: projetoWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutTarefasInput = {
    create?: XOR<usuarioCreateWithoutTarefasInput, usuarioUncheckedCreateWithoutTarefasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTarefasInput
    connect?: usuarioWhereUniqueInput
  }

  export type comentarioCreateNestedManyWithoutTarefaInput = {
    create?: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput> | comentarioCreateWithoutTarefaInput[] | comentarioUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutTarefaInput | comentarioCreateOrConnectWithoutTarefaInput[]
    createMany?: comentarioCreateManyTarefaInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type responsavel_tarefaCreateNestedManyWithoutTarefaInput = {
    create?: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput> | responsavel_tarefaCreateWithoutTarefaInput[] | responsavel_tarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutTarefaInput | responsavel_tarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: responsavel_tarefaCreateManyTarefaInputEnvelope
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
  }

  export type comentarioUncheckedCreateNestedManyWithoutTarefaInput = {
    create?: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput> | comentarioCreateWithoutTarefaInput[] | comentarioUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutTarefaInput | comentarioCreateOrConnectWithoutTarefaInput[]
    createMany?: comentarioCreateManyTarefaInputEnvelope
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
  }

  export type responsavel_tarefaUncheckedCreateNestedManyWithoutTarefaInput = {
    create?: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput> | responsavel_tarefaCreateWithoutTarefaInput[] | responsavel_tarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutTarefaInput | responsavel_tarefaCreateOrConnectWithoutTarefaInput[]
    createMany?: responsavel_tarefaCreateManyTarefaInputEnvelope
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type projetoUpdateOneWithoutTarefaNestedInput = {
    create?: XOR<projetoCreateWithoutTarefaInput, projetoUncheckedCreateWithoutTarefaInput>
    connectOrCreate?: projetoCreateOrConnectWithoutTarefaInput
    upsert?: projetoUpsertWithoutTarefaInput
    disconnect?: projetoWhereInput | boolean
    delete?: projetoWhereInput | boolean
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutTarefaInput, projetoUpdateWithoutTarefaInput>, projetoUncheckedUpdateWithoutTarefaInput>
  }

  export type usuarioUpdateOneWithoutTarefasNestedInput = {
    create?: XOR<usuarioCreateWithoutTarefasInput, usuarioUncheckedCreateWithoutTarefasInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutTarefasInput
    upsert?: usuarioUpsertWithoutTarefasInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutTarefasInput, usuarioUpdateWithoutTarefasInput>, usuarioUncheckedUpdateWithoutTarefasInput>
  }

  export type comentarioUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput> | comentarioCreateWithoutTarefaInput[] | comentarioUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutTarefaInput | comentarioCreateOrConnectWithoutTarefaInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutTarefaInput | comentarioUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: comentarioCreateManyTarefaInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutTarefaInput | comentarioUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutTarefaInput | comentarioUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type responsavel_tarefaUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput> | responsavel_tarefaCreateWithoutTarefaInput[] | responsavel_tarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutTarefaInput | responsavel_tarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: responsavel_tarefaUpsertWithWhereUniqueWithoutTarefaInput | responsavel_tarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: responsavel_tarefaCreateManyTarefaInputEnvelope
    set?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    disconnect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    delete?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    update?: responsavel_tarefaUpdateWithWhereUniqueWithoutTarefaInput | responsavel_tarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: responsavel_tarefaUpdateManyWithWhereWithoutTarefaInput | responsavel_tarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type comentarioUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput> | comentarioCreateWithoutTarefaInput[] | comentarioUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: comentarioCreateOrConnectWithoutTarefaInput | comentarioCreateOrConnectWithoutTarefaInput[]
    upsert?: comentarioUpsertWithWhereUniqueWithoutTarefaInput | comentarioUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: comentarioCreateManyTarefaInputEnvelope
    set?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    disconnect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    delete?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    connect?: comentarioWhereUniqueInput | comentarioWhereUniqueInput[]
    update?: comentarioUpdateWithWhereUniqueWithoutTarefaInput | comentarioUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: comentarioUpdateManyWithWhereWithoutTarefaInput | comentarioUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
  }

  export type responsavel_tarefaUncheckedUpdateManyWithoutTarefaNestedInput = {
    create?: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput> | responsavel_tarefaCreateWithoutTarefaInput[] | responsavel_tarefaUncheckedCreateWithoutTarefaInput[]
    connectOrCreate?: responsavel_tarefaCreateOrConnectWithoutTarefaInput | responsavel_tarefaCreateOrConnectWithoutTarefaInput[]
    upsert?: responsavel_tarefaUpsertWithWhereUniqueWithoutTarefaInput | responsavel_tarefaUpsertWithWhereUniqueWithoutTarefaInput[]
    createMany?: responsavel_tarefaCreateManyTarefaInputEnvelope
    set?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    disconnect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    delete?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    connect?: responsavel_tarefaWhereUniqueInput | responsavel_tarefaWhereUniqueInput[]
    update?: responsavel_tarefaUpdateWithWhereUniqueWithoutTarefaInput | responsavel_tarefaUpdateWithWhereUniqueWithoutTarefaInput[]
    updateMany?: responsavel_tarefaUpdateManyWithWhereWithoutTarefaInput | responsavel_tarefaUpdateManyWithWhereWithoutTarefaInput[]
    deleteMany?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
  }

  export type usuarioCreateNestedOneWithoutProjetosInput = {
    create?: XOR<usuarioCreateWithoutProjetosInput, usuarioUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetosInput
    connect?: usuarioWhereUniqueInput
  }

  export type projetoCreateNestedOneWithoutUsuariosInput = {
    create?: XOR<projetoCreateWithoutUsuariosInput, projetoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutUsuariosInput
    connect?: projetoWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutProjetosNestedInput = {
    create?: XOR<usuarioCreateWithoutProjetosInput, usuarioUncheckedCreateWithoutProjetosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutProjetosInput
    upsert?: usuarioUpsertWithoutProjetosInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutProjetosInput, usuarioUpdateWithoutProjetosInput>, usuarioUncheckedUpdateWithoutProjetosInput>
  }

  export type projetoUpdateOneRequiredWithoutUsuariosNestedInput = {
    create?: XOR<projetoCreateWithoutUsuariosInput, projetoUncheckedCreateWithoutUsuariosInput>
    connectOrCreate?: projetoCreateOrConnectWithoutUsuariosInput
    upsert?: projetoUpsertWithoutUsuariosInput
    connect?: projetoWhereUniqueInput
    update?: XOR<XOR<projetoUpdateToOneWithWhereWithoutUsuariosInput, projetoUpdateWithoutUsuariosInput>, projetoUncheckedUpdateWithoutUsuariosInput>
  }

  export type usuarioCreateNestedOneWithoutResponsaveisInput = {
    create?: XOR<usuarioCreateWithoutResponsaveisInput, usuarioUncheckedCreateWithoutResponsaveisInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutResponsaveisInput
    connect?: usuarioWhereUniqueInput
  }

  export type tarefaCreateNestedOneWithoutResponsavel_tarefaInput = {
    create?: XOR<tarefaCreateWithoutResponsavel_tarefaInput, tarefaUncheckedCreateWithoutResponsavel_tarefaInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutResponsavel_tarefaInput
    connect?: tarefaWhereUniqueInput
  }

  export type usuarioUpdateOneRequiredWithoutResponsaveisNestedInput = {
    create?: XOR<usuarioCreateWithoutResponsaveisInput, usuarioUncheckedCreateWithoutResponsaveisInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutResponsaveisInput
    upsert?: usuarioUpsertWithoutResponsaveisInput
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutResponsaveisInput, usuarioUpdateWithoutResponsaveisInput>, usuarioUncheckedUpdateWithoutResponsaveisInput>
  }

  export type tarefaUpdateOneRequiredWithoutResponsavel_tarefaNestedInput = {
    create?: XOR<tarefaCreateWithoutResponsavel_tarefaInput, tarefaUncheckedCreateWithoutResponsavel_tarefaInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutResponsavel_tarefaInput
    upsert?: tarefaUpsertWithoutResponsavel_tarefaInput
    connect?: tarefaWhereUniqueInput
    update?: XOR<XOR<tarefaUpdateToOneWithWhereWithoutResponsavel_tarefaInput, tarefaUpdateWithoutResponsavel_tarefaInput>, tarefaUncheckedUpdateWithoutResponsavel_tarefaInput>
  }

  export type tarefaCreateNestedOneWithoutComentarioInput = {
    create?: XOR<tarefaCreateWithoutComentarioInput, tarefaUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutComentarioInput
    connect?: tarefaWhereUniqueInput
  }

  export type usuarioCreateNestedOneWithoutComentariosInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    connect?: usuarioWhereUniqueInput
  }

  export type tarefaUpdateOneWithoutComentarioNestedInput = {
    create?: XOR<tarefaCreateWithoutComentarioInput, tarefaUncheckedCreateWithoutComentarioInput>
    connectOrCreate?: tarefaCreateOrConnectWithoutComentarioInput
    upsert?: tarefaUpsertWithoutComentarioInput
    disconnect?: tarefaWhereInput | boolean
    delete?: tarefaWhereInput | boolean
    connect?: tarefaWhereUniqueInput
    update?: XOR<XOR<tarefaUpdateToOneWithWhereWithoutComentarioInput, tarefaUpdateWithoutComentarioInput>, tarefaUncheckedUpdateWithoutComentarioInput>
  }

  export type usuarioUpdateOneWithoutComentariosNestedInput = {
    create?: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    connectOrCreate?: usuarioCreateOrConnectWithoutComentariosInput
    upsert?: usuarioUpsertWithoutComentariosInput
    disconnect?: usuarioWhereInput | boolean
    delete?: usuarioWhereInput | boolean
    connect?: usuarioWhereUniqueInput
    update?: XOR<XOR<usuarioUpdateToOneWithWhereWithoutComentariosInput, usuarioUpdateWithoutComentariosInput>, usuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[]
    notIn?: Buffer[]
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type usuario_projetoCreateWithoutUsuarioInput = {
    projeto: projetoCreateNestedOneWithoutUsuariosInput
  }

  export type usuario_projetoUncheckedCreateWithoutUsuarioInput = {
    idprojeto: number
  }

  export type usuario_projetoCreateOrConnectWithoutUsuarioInput = {
    where: usuario_projetoWhereUniqueInput
    create: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput>
  }

  export type usuario_projetoCreateManyUsuarioInputEnvelope = {
    data: usuario_projetoCreateManyUsuarioInput | usuario_projetoCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type tarefaCreateWithoutGestorInput = {
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    projeto?: projetoCreateNestedOneWithoutTarefaInput
    comentario?: comentarioCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutGestorInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
    comentario?: comentarioUncheckedCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutGestorInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput>
  }

  export type tarefaCreateManyGestorInputEnvelope = {
    data: tarefaCreateManyGestorInput | tarefaCreateManyGestorInput[]
    skipDuplicates?: boolean
  }

  export type comentarioCreateWithoutUsuarioInput = {
    texto?: string | null
    tarefa?: tarefaCreateNestedOneWithoutComentarioInput
  }

  export type comentarioUncheckedCreateWithoutUsuarioInput = {
    idcomentario?: number
    texto?: string | null
    id_tarefa?: number | null
  }

  export type comentarioCreateOrConnectWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    create: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type comentarioCreateManyUsuarioInputEnvelope = {
    data: comentarioCreateManyUsuarioInput | comentarioCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type responsavel_tarefaCreateWithoutUsuarioInput = {
    tarefa: tarefaCreateNestedOneWithoutResponsavel_tarefaInput
  }

  export type responsavel_tarefaUncheckedCreateWithoutUsuarioInput = {
    id_tarefa: number
  }

  export type responsavel_tarefaCreateOrConnectWithoutUsuarioInput = {
    where: responsavel_tarefaWhereUniqueInput
    create: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput>
  }

  export type responsavel_tarefaCreateManyUsuarioInputEnvelope = {
    data: responsavel_tarefaCreateManyUsuarioInput | responsavel_tarefaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type projetoCreateWithoutGestorInput = {
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    usuarios?: usuario_projetoCreateNestedManyWithoutProjetoInput
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutGestorInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    usuarios?: usuario_projetoUncheckedCreateNestedManyWithoutProjetoInput
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutGestorInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput>
  }

  export type projetoCreateManyGestorInputEnvelope = {
    data: projetoCreateManyGestorInput | projetoCreateManyGestorInput[]
    skipDuplicates?: boolean
  }

  export type usuario_projetoUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: usuario_projetoWhereUniqueInput
    update: XOR<usuario_projetoUpdateWithoutUsuarioInput, usuario_projetoUncheckedUpdateWithoutUsuarioInput>
    create: XOR<usuario_projetoCreateWithoutUsuarioInput, usuario_projetoUncheckedCreateWithoutUsuarioInput>
  }

  export type usuario_projetoUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: usuario_projetoWhereUniqueInput
    data: XOR<usuario_projetoUpdateWithoutUsuarioInput, usuario_projetoUncheckedUpdateWithoutUsuarioInput>
  }

  export type usuario_projetoUpdateManyWithWhereWithoutUsuarioInput = {
    where: usuario_projetoScalarWhereInput
    data: XOR<usuario_projetoUpdateManyMutationInput, usuario_projetoUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type usuario_projetoScalarWhereInput = {
    AND?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
    OR?: usuario_projetoScalarWhereInput[]
    NOT?: usuario_projetoScalarWhereInput | usuario_projetoScalarWhereInput[]
    idusuario?: IntFilter<"usuario_projeto"> | number
    idprojeto?: IntFilter<"usuario_projeto"> | number
  }

  export type tarefaUpsertWithWhereUniqueWithoutGestorInput = {
    where: tarefaWhereUniqueInput
    update: XOR<tarefaUpdateWithoutGestorInput, tarefaUncheckedUpdateWithoutGestorInput>
    create: XOR<tarefaCreateWithoutGestorInput, tarefaUncheckedCreateWithoutGestorInput>
  }

  export type tarefaUpdateWithWhereUniqueWithoutGestorInput = {
    where: tarefaWhereUniqueInput
    data: XOR<tarefaUpdateWithoutGestorInput, tarefaUncheckedUpdateWithoutGestorInput>
  }

  export type tarefaUpdateManyWithWhereWithoutGestorInput = {
    where: tarefaScalarWhereInput
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyWithoutGestorInput>
  }

  export type tarefaScalarWhereInput = {
    AND?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
    OR?: tarefaScalarWhereInput[]
    NOT?: tarefaScalarWhereInput | tarefaScalarWhereInput[]
    idtarefa?: IntFilter<"tarefa"> | number
    nome?: StringNullableFilter<"tarefa"> | string | null
    data_inicio?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    prazo?: DateTimeNullableFilter<"tarefa"> | Date | string | null
    status?: StringNullableFilter<"tarefa"> | string | null
    descricao?: StringNullableFilter<"tarefa"> | string | null
    id_projeto?: IntNullableFilter<"tarefa"> | number | null
    id_gestor?: IntNullableFilter<"tarefa"> | number | null
  }

  export type comentarioUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    update: XOR<comentarioUpdateWithoutUsuarioInput, comentarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<comentarioCreateWithoutUsuarioInput, comentarioUncheckedCreateWithoutUsuarioInput>
  }

  export type comentarioUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: comentarioWhereUniqueInput
    data: XOR<comentarioUpdateWithoutUsuarioInput, comentarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type comentarioUpdateManyWithWhereWithoutUsuarioInput = {
    where: comentarioScalarWhereInput
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type comentarioScalarWhereInput = {
    AND?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
    OR?: comentarioScalarWhereInput[]
    NOT?: comentarioScalarWhereInput | comentarioScalarWhereInput[]
    idcomentario?: IntFilter<"comentario"> | number
    texto?: StringNullableFilter<"comentario"> | string | null
    id_tarefa?: IntNullableFilter<"comentario"> | number | null
    id_usuario?: IntNullableFilter<"comentario"> | number | null
  }

  export type responsavel_tarefaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: responsavel_tarefaWhereUniqueInput
    update: XOR<responsavel_tarefaUpdateWithoutUsuarioInput, responsavel_tarefaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<responsavel_tarefaCreateWithoutUsuarioInput, responsavel_tarefaUncheckedCreateWithoutUsuarioInput>
  }

  export type responsavel_tarefaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: responsavel_tarefaWhereUniqueInput
    data: XOR<responsavel_tarefaUpdateWithoutUsuarioInput, responsavel_tarefaUncheckedUpdateWithoutUsuarioInput>
  }

  export type responsavel_tarefaUpdateManyWithWhereWithoutUsuarioInput = {
    where: responsavel_tarefaScalarWhereInput
    data: XOR<responsavel_tarefaUpdateManyMutationInput, responsavel_tarefaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type responsavel_tarefaScalarWhereInput = {
    AND?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
    OR?: responsavel_tarefaScalarWhereInput[]
    NOT?: responsavel_tarefaScalarWhereInput | responsavel_tarefaScalarWhereInput[]
    id_usuario?: IntFilter<"responsavel_tarefa"> | number
    id_tarefa?: IntFilter<"responsavel_tarefa"> | number
  }

  export type projetoUpsertWithWhereUniqueWithoutGestorInput = {
    where: projetoWhereUniqueInput
    update: XOR<projetoUpdateWithoutGestorInput, projetoUncheckedUpdateWithoutGestorInput>
    create: XOR<projetoCreateWithoutGestorInput, projetoUncheckedCreateWithoutGestorInput>
  }

  export type projetoUpdateWithWhereUniqueWithoutGestorInput = {
    where: projetoWhereUniqueInput
    data: XOR<projetoUpdateWithoutGestorInput, projetoUncheckedUpdateWithoutGestorInput>
  }

  export type projetoUpdateManyWithWhereWithoutGestorInput = {
    where: projetoScalarWhereInput
    data: XOR<projetoUpdateManyMutationInput, projetoUncheckedUpdateManyWithoutGestorInput>
  }

  export type projetoScalarWhereInput = {
    AND?: projetoScalarWhereInput | projetoScalarWhereInput[]
    OR?: projetoScalarWhereInput[]
    NOT?: projetoScalarWhereInput | projetoScalarWhereInput[]
    idprojeto?: IntFilter<"projeto"> | number
    nome?: StringFilter<"projeto"> | string
    valor?: DecimalFilter<"projeto"> | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFilter<"projeto"> | Date | string
    prazo?: DateTimeFilter<"projeto"> | Date | string
    status?: StringFilter<"projeto"> | string
    descricao?: StringFilter<"projeto"> | string
    foto?: BytesFilter<"projeto"> | Buffer
    id_gestor?: IntFilter<"projeto"> | number
  }

  export type usuario_projetoCreateWithoutProjetoInput = {
    usuario: usuarioCreateNestedOneWithoutProjetosInput
  }

  export type usuario_projetoUncheckedCreateWithoutProjetoInput = {
    idusuario: number
  }

  export type usuario_projetoCreateOrConnectWithoutProjetoInput = {
    where: usuario_projetoWhereUniqueInput
    create: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput>
  }

  export type usuario_projetoCreateManyProjetoInputEnvelope = {
    data: usuario_projetoCreateManyProjetoInput | usuario_projetoCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type usuarioCreateWithoutProjetos_gestorInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaCreateNestedManyWithoutGestorInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioUncheckedCreateWithoutProjetos_gestorInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaUncheckedCreateNestedManyWithoutGestorInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type usuarioCreateOrConnectWithoutProjetos_gestorInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutProjetos_gestorInput, usuarioUncheckedCreateWithoutProjetos_gestorInput>
  }

  export type tarefaCreateWithoutProjetoInput = {
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    gestor?: usuarioCreateNestedOneWithoutTarefasInput
    comentario?: comentarioCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutProjetoInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_gestor?: number | null
    comentario?: comentarioUncheckedCreateNestedManyWithoutTarefaInput
    responsavel_tarefa?: responsavel_tarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutProjetoInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput>
  }

  export type tarefaCreateManyProjetoInputEnvelope = {
    data: tarefaCreateManyProjetoInput | tarefaCreateManyProjetoInput[]
    skipDuplicates?: boolean
  }

  export type usuario_projetoUpsertWithWhereUniqueWithoutProjetoInput = {
    where: usuario_projetoWhereUniqueInput
    update: XOR<usuario_projetoUpdateWithoutProjetoInput, usuario_projetoUncheckedUpdateWithoutProjetoInput>
    create: XOR<usuario_projetoCreateWithoutProjetoInput, usuario_projetoUncheckedCreateWithoutProjetoInput>
  }

  export type usuario_projetoUpdateWithWhereUniqueWithoutProjetoInput = {
    where: usuario_projetoWhereUniqueInput
    data: XOR<usuario_projetoUpdateWithoutProjetoInput, usuario_projetoUncheckedUpdateWithoutProjetoInput>
  }

  export type usuario_projetoUpdateManyWithWhereWithoutProjetoInput = {
    where: usuario_projetoScalarWhereInput
    data: XOR<usuario_projetoUpdateManyMutationInput, usuario_projetoUncheckedUpdateManyWithoutProjetoInput>
  }

  export type usuarioUpsertWithoutProjetos_gestorInput = {
    update: XOR<usuarioUpdateWithoutProjetos_gestorInput, usuarioUncheckedUpdateWithoutProjetos_gestorInput>
    create: XOR<usuarioCreateWithoutProjetos_gestorInput, usuarioUncheckedCreateWithoutProjetos_gestorInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutProjetos_gestorInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutProjetos_gestorInput, usuarioUncheckedUpdateWithoutProjetos_gestorInput>
  }

  export type usuarioUpdateWithoutProjetos_gestorInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUpdateManyWithoutUsuarioNestedInput
  }

  export type usuarioUncheckedUpdateWithoutProjetos_gestorInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUncheckedUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type tarefaUpsertWithWhereUniqueWithoutProjetoInput = {
    where: tarefaWhereUniqueInput
    update: XOR<tarefaUpdateWithoutProjetoInput, tarefaUncheckedUpdateWithoutProjetoInput>
    create: XOR<tarefaCreateWithoutProjetoInput, tarefaUncheckedCreateWithoutProjetoInput>
  }

  export type tarefaUpdateWithWhereUniqueWithoutProjetoInput = {
    where: tarefaWhereUniqueInput
    data: XOR<tarefaUpdateWithoutProjetoInput, tarefaUncheckedUpdateWithoutProjetoInput>
  }

  export type tarefaUpdateManyWithWhereWithoutProjetoInput = {
    where: tarefaScalarWhereInput
    data: XOR<tarefaUpdateManyMutationInput, tarefaUncheckedUpdateManyWithoutProjetoInput>
  }

  export type projetoCreateWithoutTarefaInput = {
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    usuarios?: usuario_projetoCreateNestedManyWithoutProjetoInput
    gestor?: usuarioCreateNestedOneWithoutProjetos_gestorInput
  }

  export type projetoUncheckedCreateWithoutTarefaInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    id_gestor: number
    usuarios?: usuario_projetoUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutTarefaInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutTarefaInput, projetoUncheckedCreateWithoutTarefaInput>
  }

  export type usuarioCreateWithoutTarefasInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoCreateNestedManyWithoutUsuarioInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoCreateNestedManyWithoutGestorInput
  }

  export type usuarioUncheckedCreateWithoutTarefasInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoUncheckedCreateNestedManyWithoutGestorInput
  }

  export type usuarioCreateOrConnectWithoutTarefasInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutTarefasInput, usuarioUncheckedCreateWithoutTarefasInput>
  }

  export type comentarioCreateWithoutTarefaInput = {
    texto?: string | null
    usuario?: usuarioCreateNestedOneWithoutComentariosInput
  }

  export type comentarioUncheckedCreateWithoutTarefaInput = {
    idcomentario?: number
    texto?: string | null
    id_usuario?: number | null
  }

  export type comentarioCreateOrConnectWithoutTarefaInput = {
    where: comentarioWhereUniqueInput
    create: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput>
  }

  export type comentarioCreateManyTarefaInputEnvelope = {
    data: comentarioCreateManyTarefaInput | comentarioCreateManyTarefaInput[]
    skipDuplicates?: boolean
  }

  export type responsavel_tarefaCreateWithoutTarefaInput = {
    usuario: usuarioCreateNestedOneWithoutResponsaveisInput
  }

  export type responsavel_tarefaUncheckedCreateWithoutTarefaInput = {
    id_usuario: number
  }

  export type responsavel_tarefaCreateOrConnectWithoutTarefaInput = {
    where: responsavel_tarefaWhereUniqueInput
    create: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput>
  }

  export type responsavel_tarefaCreateManyTarefaInputEnvelope = {
    data: responsavel_tarefaCreateManyTarefaInput | responsavel_tarefaCreateManyTarefaInput[]
    skipDuplicates?: boolean
  }

  export type projetoUpsertWithoutTarefaInput = {
    update: XOR<projetoUpdateWithoutTarefaInput, projetoUncheckedUpdateWithoutTarefaInput>
    create: XOR<projetoCreateWithoutTarefaInput, projetoUncheckedCreateWithoutTarefaInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutTarefaInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutTarefaInput, projetoUncheckedUpdateWithoutTarefaInput>
  }

  export type projetoUpdateWithoutTarefaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    usuarios?: usuario_projetoUpdateManyWithoutProjetoNestedInput
    gestor?: usuarioUpdateOneWithoutProjetos_gestorNestedInput
  }

  export type projetoUncheckedUpdateWithoutTarefaInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    id_gestor?: IntFieldUpdateOperationsInput | number
    usuarios?: usuario_projetoUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type usuarioUpsertWithoutTarefasInput = {
    update: XOR<usuarioUpdateWithoutTarefasInput, usuarioUncheckedUpdateWithoutTarefasInput>
    create: XOR<usuarioCreateWithoutTarefasInput, usuarioUncheckedCreateWithoutTarefasInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutTarefasInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutTarefasInput, usuarioUncheckedUpdateWithoutTarefasInput>
  }

  export type usuarioUpdateWithoutTarefasInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUpdateManyWithoutGestorNestedInput
  }

  export type usuarioUncheckedUpdateWithoutTarefasInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUncheckedUpdateManyWithoutGestorNestedInput
  }

  export type comentarioUpsertWithWhereUniqueWithoutTarefaInput = {
    where: comentarioWhereUniqueInput
    update: XOR<comentarioUpdateWithoutTarefaInput, comentarioUncheckedUpdateWithoutTarefaInput>
    create: XOR<comentarioCreateWithoutTarefaInput, comentarioUncheckedCreateWithoutTarefaInput>
  }

  export type comentarioUpdateWithWhereUniqueWithoutTarefaInput = {
    where: comentarioWhereUniqueInput
    data: XOR<comentarioUpdateWithoutTarefaInput, comentarioUncheckedUpdateWithoutTarefaInput>
  }

  export type comentarioUpdateManyWithWhereWithoutTarefaInput = {
    where: comentarioScalarWhereInput
    data: XOR<comentarioUpdateManyMutationInput, comentarioUncheckedUpdateManyWithoutTarefaInput>
  }

  export type responsavel_tarefaUpsertWithWhereUniqueWithoutTarefaInput = {
    where: responsavel_tarefaWhereUniqueInput
    update: XOR<responsavel_tarefaUpdateWithoutTarefaInput, responsavel_tarefaUncheckedUpdateWithoutTarefaInput>
    create: XOR<responsavel_tarefaCreateWithoutTarefaInput, responsavel_tarefaUncheckedCreateWithoutTarefaInput>
  }

  export type responsavel_tarefaUpdateWithWhereUniqueWithoutTarefaInput = {
    where: responsavel_tarefaWhereUniqueInput
    data: XOR<responsavel_tarefaUpdateWithoutTarefaInput, responsavel_tarefaUncheckedUpdateWithoutTarefaInput>
  }

  export type responsavel_tarefaUpdateManyWithWhereWithoutTarefaInput = {
    where: responsavel_tarefaScalarWhereInput
    data: XOR<responsavel_tarefaUpdateManyMutationInput, responsavel_tarefaUncheckedUpdateManyWithoutTarefaInput>
  }

  export type usuarioCreateWithoutProjetosInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    tarefas?: tarefaCreateNestedManyWithoutGestorInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoCreateNestedManyWithoutGestorInput
  }

  export type usuarioUncheckedCreateWithoutProjetosInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    tarefas?: tarefaUncheckedCreateNestedManyWithoutGestorInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
    responsaveis?: responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoUncheckedCreateNestedManyWithoutGestorInput
  }

  export type usuarioCreateOrConnectWithoutProjetosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutProjetosInput, usuarioUncheckedCreateWithoutProjetosInput>
  }

  export type projetoCreateWithoutUsuariosInput = {
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    gestor?: usuarioCreateNestedOneWithoutProjetos_gestorInput
    tarefa?: tarefaCreateNestedManyWithoutProjetoInput
  }

  export type projetoUncheckedCreateWithoutUsuariosInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
    id_gestor: number
    tarefa?: tarefaUncheckedCreateNestedManyWithoutProjetoInput
  }

  export type projetoCreateOrConnectWithoutUsuariosInput = {
    where: projetoWhereUniqueInput
    create: XOR<projetoCreateWithoutUsuariosInput, projetoUncheckedCreateWithoutUsuariosInput>
  }

  export type usuarioUpsertWithoutProjetosInput = {
    update: XOR<usuarioUpdateWithoutProjetosInput, usuarioUncheckedUpdateWithoutProjetosInput>
    create: XOR<usuarioCreateWithoutProjetosInput, usuarioUncheckedCreateWithoutProjetosInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutProjetosInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutProjetosInput, usuarioUncheckedUpdateWithoutProjetosInput>
  }

  export type usuarioUpdateWithoutProjetosInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    tarefas?: tarefaUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUpdateManyWithoutGestorNestedInput
  }

  export type usuarioUncheckedUpdateWithoutProjetosInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    tarefas?: tarefaUncheckedUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    responsaveis?: responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUncheckedUpdateManyWithoutGestorNestedInput
  }

  export type projetoUpsertWithoutUsuariosInput = {
    update: XOR<projetoUpdateWithoutUsuariosInput, projetoUncheckedUpdateWithoutUsuariosInput>
    create: XOR<projetoCreateWithoutUsuariosInput, projetoUncheckedCreateWithoutUsuariosInput>
    where?: projetoWhereInput
  }

  export type projetoUpdateToOneWithWhereWithoutUsuariosInput = {
    where?: projetoWhereInput
    data: XOR<projetoUpdateWithoutUsuariosInput, projetoUncheckedUpdateWithoutUsuariosInput>
  }

  export type projetoUpdateWithoutUsuariosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    gestor?: usuarioUpdateOneWithoutProjetos_gestorNestedInput
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutUsuariosInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    id_gestor?: IntFieldUpdateOperationsInput | number
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type usuarioCreateWithoutResponsaveisInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaCreateNestedManyWithoutGestorInput
    comentarios?: comentarioCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoCreateNestedManyWithoutGestorInput
  }

  export type usuarioUncheckedCreateWithoutResponsaveisInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaUncheckedCreateNestedManyWithoutGestorInput
    comentarios?: comentarioUncheckedCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoUncheckedCreateNestedManyWithoutGestorInput
  }

  export type usuarioCreateOrConnectWithoutResponsaveisInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutResponsaveisInput, usuarioUncheckedCreateWithoutResponsaveisInput>
  }

  export type tarefaCreateWithoutResponsavel_tarefaInput = {
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    projeto?: projetoCreateNestedOneWithoutTarefaInput
    gestor?: usuarioCreateNestedOneWithoutTarefasInput
    comentario?: comentarioCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutResponsavel_tarefaInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
    id_gestor?: number | null
    comentario?: comentarioUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutResponsavel_tarefaInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutResponsavel_tarefaInput, tarefaUncheckedCreateWithoutResponsavel_tarefaInput>
  }

  export type usuarioUpsertWithoutResponsaveisInput = {
    update: XOR<usuarioUpdateWithoutResponsaveisInput, usuarioUncheckedUpdateWithoutResponsaveisInput>
    create: XOR<usuarioCreateWithoutResponsaveisInput, usuarioUncheckedCreateWithoutResponsaveisInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutResponsaveisInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutResponsaveisInput, usuarioUncheckedUpdateWithoutResponsaveisInput>
  }

  export type usuarioUpdateWithoutResponsaveisInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUpdateManyWithoutGestorNestedInput
  }

  export type usuarioUncheckedUpdateWithoutResponsaveisInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUncheckedUpdateManyWithoutGestorNestedInput
    comentarios?: comentarioUncheckedUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUncheckedUpdateManyWithoutGestorNestedInput
  }

  export type tarefaUpsertWithoutResponsavel_tarefaInput = {
    update: XOR<tarefaUpdateWithoutResponsavel_tarefaInput, tarefaUncheckedUpdateWithoutResponsavel_tarefaInput>
    create: XOR<tarefaCreateWithoutResponsavel_tarefaInput, tarefaUncheckedCreateWithoutResponsavel_tarefaInput>
    where?: tarefaWhereInput
  }

  export type tarefaUpdateToOneWithWhereWithoutResponsavel_tarefaInput = {
    where?: tarefaWhereInput
    data: XOR<tarefaUpdateWithoutResponsavel_tarefaInput, tarefaUncheckedUpdateWithoutResponsavel_tarefaInput>
  }

  export type tarefaUpdateWithoutResponsavel_tarefaInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: projetoUpdateOneWithoutTarefaNestedInput
    gestor?: usuarioUpdateOneWithoutTarefasNestedInput
    comentario?: comentarioUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutResponsavel_tarefaInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: comentarioUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaCreateWithoutComentarioInput = {
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    projeto?: projetoCreateNestedOneWithoutTarefaInput
    gestor?: usuarioCreateNestedOneWithoutTarefasInput
    responsavel_tarefa?: responsavel_tarefaCreateNestedManyWithoutTarefaInput
  }

  export type tarefaUncheckedCreateWithoutComentarioInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
    id_gestor?: number | null
    responsavel_tarefa?: responsavel_tarefaUncheckedCreateNestedManyWithoutTarefaInput
  }

  export type tarefaCreateOrConnectWithoutComentarioInput = {
    where: tarefaWhereUniqueInput
    create: XOR<tarefaCreateWithoutComentarioInput, tarefaUncheckedCreateWithoutComentarioInput>
  }

  export type usuarioCreateWithoutComentariosInput = {
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaCreateNestedManyWithoutGestorInput
    responsaveis?: responsavel_tarefaCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoCreateNestedManyWithoutGestorInput
  }

  export type usuarioUncheckedCreateWithoutComentariosInput = {
    idusuario?: number
    cpf: string
    nome: string
    hash_senha: string
    email: string
    papel: string
    usuario_tipo?: number
    projetos?: usuario_projetoUncheckedCreateNestedManyWithoutUsuarioInput
    tarefas?: tarefaUncheckedCreateNestedManyWithoutGestorInput
    responsaveis?: responsavel_tarefaUncheckedCreateNestedManyWithoutUsuarioInput
    projetos_gestor?: projetoUncheckedCreateNestedManyWithoutGestorInput
  }

  export type usuarioCreateOrConnectWithoutComentariosInput = {
    where: usuarioWhereUniqueInput
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
  }

  export type tarefaUpsertWithoutComentarioInput = {
    update: XOR<tarefaUpdateWithoutComentarioInput, tarefaUncheckedUpdateWithoutComentarioInput>
    create: XOR<tarefaCreateWithoutComentarioInput, tarefaUncheckedCreateWithoutComentarioInput>
    where?: tarefaWhereInput
  }

  export type tarefaUpdateToOneWithWhereWithoutComentarioInput = {
    where?: tarefaWhereInput
    data: XOR<tarefaUpdateWithoutComentarioInput, tarefaUncheckedUpdateWithoutComentarioInput>
  }

  export type tarefaUpdateWithoutComentarioInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: projetoUpdateOneWithoutTarefaNestedInput
    gestor?: usuarioUpdateOneWithoutTarefasNestedInput
    responsavel_tarefa?: responsavel_tarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutComentarioInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
    responsavel_tarefa?: responsavel_tarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type usuarioUpsertWithoutComentariosInput = {
    update: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
    create: XOR<usuarioCreateWithoutComentariosInput, usuarioUncheckedCreateWithoutComentariosInput>
    where?: usuarioWhereInput
  }

  export type usuarioUpdateToOneWithWhereWithoutComentariosInput = {
    where?: usuarioWhereInput
    data: XOR<usuarioUpdateWithoutComentariosInput, usuarioUncheckedUpdateWithoutComentariosInput>
  }

  export type usuarioUpdateWithoutComentariosInput = {
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUpdateManyWithoutGestorNestedInput
    responsaveis?: responsavel_tarefaUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUpdateManyWithoutGestorNestedInput
  }

  export type usuarioUncheckedUpdateWithoutComentariosInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
    cpf?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    hash_senha?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    papel?: StringFieldUpdateOperationsInput | string
    usuario_tipo?: IntFieldUpdateOperationsInput | number
    projetos?: usuario_projetoUncheckedUpdateManyWithoutUsuarioNestedInput
    tarefas?: tarefaUncheckedUpdateManyWithoutGestorNestedInput
    responsaveis?: responsavel_tarefaUncheckedUpdateManyWithoutUsuarioNestedInput
    projetos_gestor?: projetoUncheckedUpdateManyWithoutGestorNestedInput
  }

  export type usuario_projetoCreateManyUsuarioInput = {
    idprojeto: number
  }

  export type tarefaCreateManyGestorInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_projeto?: number | null
  }

  export type comentarioCreateManyUsuarioInput = {
    idcomentario?: number
    texto?: string | null
    id_tarefa?: number | null
  }

  export type responsavel_tarefaCreateManyUsuarioInput = {
    id_tarefa: number
  }

  export type projetoCreateManyGestorInput = {
    idprojeto?: number
    nome: string
    valor: Decimal | DecimalJsLike | number | string
    data_inicio: Date | string
    prazo: Date | string
    status: string
    descricao: string
    foto: Buffer
  }

  export type usuario_projetoUpdateWithoutUsuarioInput = {
    projeto?: projetoUpdateOneRequiredWithoutUsuariosNestedInput
  }

  export type usuario_projetoUncheckedUpdateWithoutUsuarioInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_projetoUncheckedUpdateManyWithoutUsuarioInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
  }

  export type tarefaUpdateWithoutGestorInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    projeto?: projetoUpdateOneWithoutTarefaNestedInput
    comentario?: comentarioUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutGestorInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: comentarioUncheckedUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateManyWithoutGestorInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_projeto?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comentarioUpdateWithoutUsuarioInput = {
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    tarefa?: tarefaUpdateOneWithoutComentarioNestedInput
  }

  export type comentarioUncheckedUpdateWithoutUsuarioInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_tarefa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comentarioUncheckedUpdateManyWithoutUsuarioInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_tarefa?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type responsavel_tarefaUpdateWithoutUsuarioInput = {
    tarefa?: tarefaUpdateOneRequiredWithoutResponsavel_tarefaNestedInput
  }

  export type responsavel_tarefaUncheckedUpdateWithoutUsuarioInput = {
    id_tarefa?: IntFieldUpdateOperationsInput | number
  }

  export type responsavel_tarefaUncheckedUpdateManyWithoutUsuarioInput = {
    id_tarefa?: IntFieldUpdateOperationsInput | number
  }

  export type projetoUpdateWithoutGestorInput = {
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    usuarios?: usuario_projetoUpdateManyWithoutProjetoNestedInput
    tarefa?: tarefaUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateWithoutGestorInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
    usuarios?: usuario_projetoUncheckedUpdateManyWithoutProjetoNestedInput
    tarefa?: tarefaUncheckedUpdateManyWithoutProjetoNestedInput
  }

  export type projetoUncheckedUpdateManyWithoutGestorInput = {
    idprojeto?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    data_inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    prazo?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    foto?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type usuario_projetoCreateManyProjetoInput = {
    idusuario: number
  }

  export type tarefaCreateManyProjetoInput = {
    idtarefa?: number
    nome?: string | null
    data_inicio?: Date | string | null
    prazo?: Date | string | null
    status?: string | null
    descricao?: string | null
    id_gestor?: number | null
  }

  export type usuario_projetoUpdateWithoutProjetoInput = {
    usuario?: usuarioUpdateOneRequiredWithoutProjetosNestedInput
  }

  export type usuario_projetoUncheckedUpdateWithoutProjetoInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type usuario_projetoUncheckedUpdateManyWithoutProjetoInput = {
    idusuario?: IntFieldUpdateOperationsInput | number
  }

  export type tarefaUpdateWithoutProjetoInput = {
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    gestor?: usuarioUpdateOneWithoutTarefasNestedInput
    comentario?: comentarioUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateWithoutProjetoInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
    comentario?: comentarioUncheckedUpdateManyWithoutTarefaNestedInput
    responsavel_tarefa?: responsavel_tarefaUncheckedUpdateManyWithoutTarefaNestedInput
  }

  export type tarefaUncheckedUpdateManyWithoutProjetoInput = {
    idtarefa?: IntFieldUpdateOperationsInput | number
    nome?: NullableStringFieldUpdateOperationsInput | string | null
    data_inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    prazo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    id_gestor?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comentarioCreateManyTarefaInput = {
    idcomentario?: number
    texto?: string | null
    id_usuario?: number | null
  }

  export type responsavel_tarefaCreateManyTarefaInput = {
    id_usuario: number
  }

  export type comentarioUpdateWithoutTarefaInput = {
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: usuarioUpdateOneWithoutComentariosNestedInput
  }

  export type comentarioUncheckedUpdateWithoutTarefaInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comentarioUncheckedUpdateManyWithoutTarefaInput = {
    idcomentario?: IntFieldUpdateOperationsInput | number
    texto?: NullableStringFieldUpdateOperationsInput | string | null
    id_usuario?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type responsavel_tarefaUpdateWithoutTarefaInput = {
    usuario?: usuarioUpdateOneRequiredWithoutResponsaveisNestedInput
  }

  export type responsavel_tarefaUncheckedUpdateWithoutTarefaInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
  }

  export type responsavel_tarefaUncheckedUpdateManyWithoutTarefaInput = {
    id_usuario?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProjetoCountOutputTypeDefaultArgs instead
     */
    export type ProjetoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProjetoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TarefaCountOutputTypeDefaultArgs instead
     */
    export type TarefaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TarefaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuarioDefaultArgs instead
     */
    export type usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use projetoDefaultArgs instead
     */
    export type projetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = projetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use tarefaDefaultArgs instead
     */
    export type tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = tarefaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usuario_projetoDefaultArgs instead
     */
    export type usuario_projetoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usuario_projetoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use responsavel_tarefaDefaultArgs instead
     */
    export type responsavel_tarefaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = responsavel_tarefaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comentarioDefaultArgs instead
     */
    export type comentarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comentarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use todoDefaultArgs instead
     */
    export type todoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = todoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}